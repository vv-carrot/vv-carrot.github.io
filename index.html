<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"vv-carrot.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="VV&#39;s Blog">
<meta property="og:url" content="https://vv-carrot.github.io/index.html">
<meta property="og:site_name" content="VV&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="vv-carrot">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://vv-carrot.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>VV's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">VV's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-相册"><a href="/gallery/" rel="section"><i class="fa fa-camera-retro fa-fw"></i>相册</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">vv-carrot</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/07/13/homewrok1%2065ba91fef84c4834ac3c759775095392/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/13/homewrok1%2065ba91fef84c4834ac3c759775095392/" class="post-title-link" itemprop="url">GAMES106 HOMEWORK1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-13 18:52:04 / 修改时间：19:38:22" itemprop="dateCreated datePublished" datetime="2023-07-13T18:52:04+08:00">2023-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GAMES106/" itemprop="url" rel="index"><span itemprop="name">GAMES106</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="homework1"><a class="markdownIt-Anchor" href="#homework1"></a> homework1</h1>
<p>gltf介绍图：</p>
<p><img src="/images/games106homewrok1/gltfOverview.png" alt="gltfOverview-2.0.0b.png" /></p>
<h2 id="骨骼动画"><a class="markdownIt-Anchor" href="#骨骼动画"></a> 骨骼动画</h2>
<h3 id="动画相关属性"><a class="markdownIt-Anchor" href="#动画相关属性"></a> <strong>动画相关属性：</strong></h3>
<p>对GLTF的理解参照了这篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65362919">glTF格式详解(动画)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e134a2599cb7">GLTF文件格式详解</a></p>
<p><strong>buffer和bufferView对象用于引用动画数据。</strong> buffer对象用来指定原始动画数据, bufferView对象用来引用buffer对象。比如下面的bufferView对象引用了索引为0的指定了原始动画数据的buffer对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;buffers&quot;</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;byteLength&quot;</span>: <span class="number">2514732</span>,</span><br><span class="line">		<span class="string">&quot;uri&quot;</span>: <span class="string">&quot;busterDrone.bin&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;bufferViews&quot;</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;buffer&quot;</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;byteLength&quot;</span>: <span class="number">196356</span>,</span><br><span class="line">		<span class="string">&quot;byteOffset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;byteStride&quot;</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;target&quot;</span>: <span class="number">34963</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;buffer&quot;</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;byteLength&quot;</span>: <span class="number">99000</span>,</span><br><span class="line">		<span class="string">&quot;byteOffset&quot;</span>: <span class="number">196356</span>,</span><br><span class="line">		<span class="string">&quot;byteStride&quot;</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;target&quot;</span>: <span class="number">34962</span></span><br><span class="line">	&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Accessor对象用于描述原始动画数据的结构。</strong> count属性表示动画数据包含了1190个动画关键帧的计时信息，每个计时信息是一个float类型的标量，所有计时信息占用了14280个字节。第二个accessor对象引用的数据在计时信息这14280字节之后，共有1190个元素，每个元素是一个包含3个分量类型为float的向量，推测SCALAR类型为计时信息，VEC3为平移信息，VEC4为旋转四元数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;accessors&quot;</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;bufferView&quot;</span>: <span class="number">3</span>,</span><br><span class="line">		<span class="string">&quot;byteOffset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;componentType&quot;</span>: <span class="number">5126</span>,</span><br><span class="line">		<span class="string">&quot;count&quot;</span>: <span class="number">1190</span>,</span><br><span class="line">		<span class="string">&quot;max&quot;</span>: [ <span class="number">0.06134279</span>, <span class="number">0.07975265</span>, <span class="number">0.02774119</span> ],</span><br><span class="line">		<span class="string">&quot;min&quot;</span>: [ <span class="number">-0.06144484</span>, <span class="number">-0.1283657</span>, <span class="number">-0.09091433</span> ],</span><br><span class="line">		<span class="string">&quot;type&quot;</span>: <span class="string">&quot;VEC3&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;bufferView&quot;</span>: <span class="number">3</span>,</span><br><span class="line">		<span class="string">&quot;byteOffset&quot;</span>: <span class="number">14280</span>,</span><br><span class="line">		<span class="string">&quot;componentType&quot;</span>: <span class="number">5126</span>,</span><br><span class="line">		<span class="string">&quot;count&quot;</span>: <span class="number">1190</span>,</span><br><span class="line">		<span class="string">&quot;max&quot;</span>: [ <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> ],</span><br><span class="line">		<span class="string">&quot;min&quot;</span>: [ <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> ],</span><br><span class="line">		<span class="string">&quot;type&quot;</span>: <span class="string">&quot;VEC3&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;bufferView&quot;</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;byteOffset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;componentType&quot;</span>: <span class="number">5126</span>,</span><br><span class="line">		<span class="string">&quot;count&quot;</span>: <span class="number">1190</span>,</span><br><span class="line">		<span class="string">&quot;max&quot;</span>: [ <span class="number">0.9694519</span>, <span class="number">0.997895</span> ],</span><br><span class="line">		<span class="string">&quot;min&quot;</span>: [ <span class="number">0.001107991</span>, <span class="number">0.001113892</span> ],</span><br><span class="line">		<span class="string">&quot;type&quot;</span>: <span class="string">&quot;VEC2&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Animation包含samplers和channels。samplers数组对象，用于描述动画数据来源。samplers数组对象，用于描述动画数据来源。</p>
<p>sampler对象包含了input和output属性，这两个属性通过索引来<strong>引用accessor对象</strong> 。这里的input属性引用了索引为2的用于计时信息accessor对象，output属性引用了索引 为3的用于旋转信息的accessor对象。此外，sampler对象还有包含了一个interpolation属性，用于指定插值方式，这里的示例使用的LINEAR插值方式。</p>
<p><strong>channel对象用于在动画数据和node对象之间建立联系</strong> ，指定动画所作用的node对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;samplers&quot;</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;input&quot;</span>: <span class="number">60</span>,</span><br><span class="line">		<span class="string">&quot;interpolation&quot;</span>: <span class="string">&quot;LINEAR&quot;</span>,</span><br><span class="line">		<span class="string">&quot;output&quot;</span>: <span class="number">61</span></span><br><span class="line">	&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;channels&quot;</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;sampler&quot;</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;target&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;node&quot;</span>: <span class="number">8</span>,</span><br><span class="line">		<span class="string">&quot;path&quot;</span>: <span class="string">&quot;translation&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码修改"><a class="markdownIt-Anchor" href="#代码修改"></a> <strong>代码修改：</strong></h3>
<p>详细查看了下gltfskinning.cpp中的动画代码。这个example读取的gltf文件多出来了一个skins属性，skins中包含inverseBindMatrices，joints，skeleton属性。</p>
<p><strong>joints</strong>记录了作为关节点的node索引。gltf中的<strong>skeleton</strong>的形式更为简单，它包含着根骨骼的Node索引。<strong>inverseBindMatrices</strong>是gltf帮忙计算好的模型空间变换到对应骨骼空间的矩阵。</p>
<p>loadSkin函数把相关的joints node 存储在skin.joints 的容器中。我自己理解的意思是在render时，从骨骼的根节点开始依次处理joints及节点的变换。</p>
<p>对于结构体的更新可以直接参考gltfskinning.cpp去更新Node，添加AnimationSampler，AnimationChannel，Animation结构体。</p>
<p>对于<strong>动画的加载loadAnimation</strong>可以直接copy gltfskinning.cpp中的代码，更新时update Animation思路也相似，然而作业中的gltf文件没有蒙皮skins属性，所以不能直接使用updateJoint函数更新，此处动画的更新需要逐个去更新节点的位置。</p>
<p>初始代码的drawNode函数中表明最终绘制节点时用到的位置为node.matrix，通过vkCmdPushConstants传入shader对应的参数就是primitive. model。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drawNode Func</span></span><br><span class="line">glm::mat4              nodeMatrix    = node.matrix;</span><br><span class="line">VulkanglTFModel::Node *currentParent = node.parent;</span><br><span class="line"><span class="keyword">while</span> (currentParent)</span><br><span class="line">&#123;</span><br><span class="line">	nodeMatrix    = currentParent-&gt;matrix * nodeMatrix;</span><br><span class="line">	currentParent = currentParent-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pass the final matrix to the vertex shader using push constants</span></span><br><span class="line"><span class="built_in">vkCmdPushConstants</span>(commandBuffer, pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, <span class="number">0</span>, <span class="built_in">sizeof</span>(glm::mat4), &amp;nodeMatrix);</span><br></pre></td></tr></table></figure>
<p>上面这一段drawNode函数的代码很重要，它实现的是一个全静态模型的传值。currentParent-&gt;matrix是初始loadNode时根据translation，rotate，scale计算得到的值，这个值在后面是没有再被更新的。</p>
<p>在update Animation函数中，根据动画的数据对每个时间node的translation，rotate，scale的值进行了插值计算更新，而传值得到的matrix并没有得到更新。</p>
<p>在drawNode中应该使用 getLocalMatrix()去计算此刻的matrix，同时不能漏掉node的parent更新，否则绘制出模型的就会错位（我就是这么做的，检查了好久的问题QAQ）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::mat4 <span class="title">getLocalMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translation) * glm::<span class="built_in">mat4</span>(rotation) * glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), scale) * matrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** update nodeMatrix **</span></span><br><span class="line">glm::mat4 nodeMatrix = node-&gt;<span class="built_in">getLocalMatrix</span>(); <span class="comment">//node-&gt;matrix;</span></span><br><span class="line">VulkanglTFModel::Node* currentParent = node-&gt;parent;</span><br><span class="line"><span class="keyword">while</span> (currentParent) &#123;</span><br><span class="line">	nodeMatrix = currentParent-&gt;<span class="built_in">getLocalMatrix</span>() * nodeMatrix;</span><br><span class="line">	currentParent = currentParent-&gt;parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化loadNode时，不需要更改node-&gt;matrix的值，加载初始的translation，rotate，scale即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the local node matrix</span></span><br><span class="line"><span class="comment">// It&#x27;s either made up from translation, rotation, scale or a 4x4 matrix</span></span><br><span class="line"><span class="keyword">if</span> (inputNode.translation.<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="comment">//node-&gt;matrix = glm::translate(node-&gt;matrix, glm::vec3(glm::make_vec3(inputNode.translation.data())));</span></span><br><span class="line">	node-&gt;translation = glm::<span class="built_in">make_vec3</span>(inputNode.translation.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inputNode.rotation.<span class="built_in">size</span>() == <span class="number">4</span>) &#123;</span><br><span class="line">	glm::quat q = glm::<span class="built_in">make_quat</span>(inputNode.rotation.<span class="built_in">data</span>());</span><br><span class="line">	<span class="comment">//node-&gt;matrix *= glm::mat4(q);</span></span><br><span class="line">	node-&gt;rotation = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inputNode.scale.<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="comment">//node-&gt;matrix = glm::scale(node-&gt;matrix, glm::vec3(glm::make_vec3(inputNode.scale.data())));</span></span><br><span class="line">	node-&gt;scale = glm::<span class="built_in">make_vec3</span>(inputNode.scale.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inputNode.matrix.<span class="built_in">size</span>() == <span class="number">16</span>) &#123;</span><br><span class="line">	node-&gt;matrix = glm::<span class="built_in">make_mat4x4</span>(inputNode.matrix.<span class="built_in">data</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于计算以后没有push constant使得shader的参数更新，所以动画并不会显示出来。在render()中updateAnimation后重新调用一遍buildCommandBuffer即可。</p>
<h2 id="pbr材质"><a class="markdownIt-Anchor" href="#pbr材质"></a> PBR材质</h2>
<h3 id="pbr材质介绍"><a class="markdownIt-Anchor" href="#pbr材质介绍"></a> <strong>PBR材质介绍：</strong></h3>
<p>PBR材质相关理解记录在了这篇文章里，作业中的实现参考了pbrbasic, pbribl, pbrtexture中的实现。</p>
<p><a href="https://vv-carrot.github.io/2023/07/06/PBR%20Material%20e973a3d0689744b4b0f4947a1c40bd54/">PBR Material</a></p>
<h3 id="数据结构更新"><a class="markdownIt-Anchor" href="#数据结构更新"></a> <strong>数据结构更新</strong></h3>
<p>pbr.cpp文件中pushconsts中传递了一些属性，然而在作业中 roughness，metallic，包括rgb参数其实都不需要cpp传递，可以直接从纹理图片中获取。所以直接更新Material的struct为下，同步修改loadMaterial中对材质参数的加载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Material</span> &#123;</span><br><span class="line">		<span class="type">uint32_t</span> baseColorTextureIndex;</span><br><span class="line">		<span class="type">uint32_t</span> metallicRoughnessTextureIndex;</span><br><span class="line">		<span class="type">uint32_t</span> normalTextureIndex = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">uint32_t</span> emissiveTextureIndex = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">uint32_t</span> occlusionTextureIndex = <span class="number">-1</span>;</span><br><span class="line">		VkDescriptorSet descriptorSet;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>如下是mesh的相关属性，primitives对应的是vertex基础属性，material是gltf文件中materials中材质的索引。gltf相关图片中已经写的比较清楚，就不再细述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;meshes&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;mesh_L_P4_17366L_P4&quot;</span>,</span><br><span class="line">	<span class="string">&quot;primitives&quot;</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;attributes&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;POSITION&quot;</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="string">&quot;NORMAL&quot;</span>: <span class="number">1</span>,</span><br><span class="line">				<span class="string">&quot;TEXCOORD_0&quot;</span>: <span class="number">2</span>,</span><br><span class="line">				<span class="string">&quot;TANGENT&quot;</span>: <span class="number">3</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;indices&quot;</span>: <span class="number">4</span>,</span><br><span class="line">			<span class="string">&quot;material&quot;</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;mode&quot;</span>: <span class="number">4</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>根据primitives中的属性，应该给Vertex 新加上一个tangent属性。</p>
<p>在loadNode的过程中，会根据mesh的primitives数据向vertexBuffer中添加数据，Vertex新增属性tangent后也需要更新loadNode代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">		glm::vec3 pos;</span><br><span class="line">		glm::vec3 normal;</span><br><span class="line">		glm::vec2 uv;</span><br><span class="line">		glm::vec3 color;</span><br><span class="line">		glm::vec4 tangent;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>在preparePipeline()中，需要更新VkVertexInputAttributeDescription的属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;VkVertexInputAttributeDescription&gt; vertexInputAttributes = &#123;</span><br><span class="line">	vks::initializers::<span class="built_in">vertexInputAttributeDescription</span>(<span class="number">0</span>, <span class="number">0</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="built_in">offsetof</span>(VulkanglTFModel::Vertex, pos)),	<span class="comment">// Location 0: Position</span></span><br><span class="line">	vks::initializers::<span class="built_in">vertexInputAttributeDescription</span>(<span class="number">0</span>, <span class="number">1</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="built_in">offsetof</span>(VulkanglTFModel::Vertex, normal)),<span class="comment">// Location 1: Normal</span></span><br><span class="line">	vks::initializers::<span class="built_in">vertexInputAttributeDescription</span>(<span class="number">0</span>, <span class="number">2</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="built_in">offsetof</span>(VulkanglTFModel::Vertex, uv)),	<span class="comment">// Location 2: Texture coordinates</span></span><br><span class="line">	vks::initializers::<span class="built_in">vertexInputAttributeDescription</span>(<span class="number">0</span>, <span class="number">3</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="built_in">offsetof</span>(VulkanglTFModel::Vertex, color)),	<span class="comment">// Location 3: Color</span></span><br><span class="line">	vks::initializers::<span class="built_in">vertexInputAttributeDescription</span>(<span class="number">0</span>, <span class="number">4</span>, VK_FORMAT_R32G32B32A32_SFLOAT, <span class="built_in">offsetof</span>(VulkanglTFModel::Vertex, tangent)),    <span class="comment">// Location 4: tangent</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="descriptorbinding更新"><a class="markdownIt-Anchor" href="#descriptorbinding更新"></a> <strong>DescriptorBinding更新</strong></h3>
<p>数据结构和pipeline相关进行更新后也需要更新Descriptor的绑定。<br />
在setupDescriptors()中对poolSizes，descriptorPoolInfo进行修改。<strong>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</strong>对应的是shader中的ubo，数量只有一个，因为material没有多余属性需要其他的ubo传递。<strong>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</strong>顾名思义是绑定的图片采样器，每张纹理有5个texture index。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;VkDescriptorPoolSize&gt; poolSizes = &#123; </span><br><span class="line">	<span class="comment">// matrices + materials uniform buffer</span></span><br><span class="line">	vks::initializers::<span class="built_in">descriptorPoolSize</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="number">1</span>),</span><br><span class="line">	<span class="comment">// One combined image sampler per model image/texture</span></span><br><span class="line">	vks::initializers::<span class="built_in">descriptorPoolSize</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="number">5</span> * glTFModel.materials.<span class="built_in">size</span>())),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于这两个类型的descriptior需要分别设定它们的layout。<br />
对于uniform设定为VK_DESCRIPTOR_TYPE_STORAGE_BUFFER，纹理设定为VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Descriptor set layout for passing matrices</span></span><br><span class="line">VkDescriptorSetLayoutBinding setLayoutBinding = vks::initializers::<span class="built_in">descriptorSetLayoutBinding</span>(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_SHADER_STAGE_VERTEX_BIT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// Descriptor set layout for passing material textures</span></span><br><span class="line">std::vector&lt;VkDescriptorSetLayoutBinding&gt; setLayoutBindings = &#123;</span><br><span class="line">	vks::initializers::<span class="built_in">descriptorSetLayoutBinding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="number">0</span>),</span><br><span class="line">	vks::initializers::<span class="built_in">descriptorSetLayoutBinding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="number">1</span>),</span><br><span class="line">	vks::initializers::<span class="built_in">descriptorSetLayoutBinding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="number">2</span>),</span><br><span class="line">	vks::initializers::<span class="built_in">descriptorSetLayoutBinding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="number">3</span>),</span><br><span class="line">	vks::initializers::<span class="built_in">descriptorSetLayoutBinding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="number">4</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据descriptorPool和descriptorLayout的相关信息得到VkDescriptorSetAllocateInfo，并根据此信息调用vkAllocateDescriptorSets分配descriptor。最后再用vks::initializers::writeDescriptorSet把每个material对应的5张纹理的descriptor写入到material的descriptor中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Descriptor sets for materials textures</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; mat : glTFModel.materials) &#123;</span><br><span class="line">	<span class="type">const</span> VkDescriptorSetAllocateInfo allocInfo = vks::initializers::<span class="built_in">descriptorSetAllocateInfo</span>(descriptorPool, &amp;descriptorSetLayouts.textures, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">VK_CHECK_RESULT</span>(<span class="built_in">vkAllocateDescriptorSets</span>(device, &amp;allocInfo, &amp;mat.descriptorSet));</span><br><span class="line">	std::vector&lt;VkWriteDescriptorSet&gt; writeDescriptorSets = &#123;</span><br><span class="line">		vks::initializers::<span class="built_in">writeDescriptorSet</span>(mat.descriptorSet, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="number">0</span>, &amp;glTFModel.images[mat.baseColorTextureIndex].texture.descriptor),</span><br><span class="line">		vks::initializers::<span class="built_in">writeDescriptorSet</span>(mat.descriptorSet, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="number">1</span>, &amp;glTFModel.images[mat.metallicRoughnessTextureIndex].texture.descriptor),</span><br><span class="line">		vks::initializers::<span class="built_in">writeDescriptorSet</span>(mat.descriptorSet, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="number">2</span>, &amp;glTFModel.images[mat.normalTextureIndex].texture.descriptor),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">if</span> (mat.emissiveTextureIndex &gt;= <span class="number">0</span> &amp;&amp; mat.emissiveTextureIndex &lt; glTFModel.images.<span class="built_in">size</span>()) writeDescriptorSets.<span class="built_in">push_back</span>(vks::initializers::<span class="built_in">writeDescriptorSet</span>(mat.descriptorSet, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="number">3</span>, &amp;glTFModel.images[mat.emissiveTextureIndex].texture.descriptor));</span><br><span class="line">	<span class="keyword">if</span> (mat.occlusionTextureIndex &gt;= <span class="number">0</span> &amp;&amp; mat.occlusionTextureIndex &lt; glTFModel.images.<span class="built_in">size</span>()) writeDescriptorSets.<span class="built_in">push_back</span>(vks::initializers::<span class="built_in">writeDescriptorSet</span>(mat.descriptorSet, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="number">4</span>, &amp;glTFModel.images[mat.occlusionTextureIndex].texture.descriptor));</span><br><span class="line">	<span class="built_in">vkUpdateDescriptorSets</span>(device, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(writeDescriptorSets.<span class="built_in">size</span>()), writeDescriptorSets.<span class="built_in">data</span>(), <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果material有其他一些参数要传入的话，可以考虑新建一个uniform buffer，此时需要对descriptorPoolSize的大小进行更新，对新建的uniform buffer的descriptor进行初始化，</p>
<p>除此外还需要参照Vertex shader uniform buffer block的建立，在prepareUniformBuffers()函数中给每个material新建一个uniform buffer并map。</p>
<h3 id="着色器编译"><a class="markdownIt-Anchor" href="#着色器编译"></a> <strong>着色器编译：</strong></h3>
<p>参照以下：</p>
<p><a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/site/guide/latest/hlsl.html">HLSL in Vulkan :: Vulkan Documentation Project Demo</a></p>
<p>vulkan读取的是编译后的spv文件，对于.frag和.vert文件编译。可以找到vulkansdk/bin/Win32/glslangValidator.exe的位置对glsl文件进行编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glsl 编译</span></span><br><span class="line">glslangValidator mesh.frag -V100 -o mesh.frag.spv</span><br><span class="line">glslangValidator mesh.vert -V100 -o mesh.vert.spv</span><br><span class="line"></span><br><span class="line"><span class="comment"># hlsl编译</span></span><br><span class="line">dxc -spirv -T vs_6_0 -E main .\mesh.vert -Fo .\mesh.vert.spv</span><br><span class="line">dxc -spirv -T ps_6_0 -E main .\mesh.frag -Fo .\mesh.frag.spv</span><br></pre></td></tr></table></figure>
<p><strong>mark一下：</strong> hlsl中的texture register，<code>space</code> 关键字 (keyword) 指定声明变量绑定到的逻辑寄存器空间。该关键字省略默认是space0，<code>register(t3, space0)</code> 永远不会与 <code>register(t3, space1)</code>冲突，也永远不会与另一个空间中可能包含 t3 的任何数组冲突。</p>
<p>要注意space的分配，分配不当程序运行时可能会出现一些问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Texture2D&lt;float4&gt; tex1 : <span class="built_in">register</span>(t3,  space0)</span><br><span class="line">Texture2D&lt;float4&gt; tex2[<span class="number">4</span>] : <span class="built_in">register</span>(t10)</span><br><span class="line">Texture2D&lt;float4&gt; tex3[<span class="number">7</span>][<span class="number">5</span>][<span class="number">3</span>] : <span class="built_in">register</span>(t20, space1)</span><br></pre></td></tr></table></figure>
<p><img src="/images/games106homewrok1/Untitled.png" alt="效果展示" /></p>
<h2 id="tonemapping-pass"><a class="markdownIt-Anchor" href="#tonemapping-pass"></a> ToneMapping Pass</h2>
<p>这部分的实现参考了，尝试了离屏渲染方法：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/641626065">GAMES106 作业1 问题整理（Tone Mapping 部分）</a></p>
<p>上面讲述了两个方案，<strong>render pass</strong>和<strong>subpass</strong>。</p>
<p><strong>render pass思路概括：将</strong>原先绘制模型的pass绘制结果作为图片存储在对应的frame buffer里，进行后处理后再渲染到屏幕上。为此需要创建新的render pass和frame buffer对原来的模型绘制进行离屏渲染。</p>
<p>用新增的一个后处理pass进行tonemapping，需要新增一个实现tonemapping的shader，然后添加一个新的pipeline去加载这个新的shader module。需要新增实现的部分就是下图中从pipeline向上到DescriptorSetLayout部分。</p>
<p><img src="/images/games106homewrok1/Untitled%201.png" alt="Untitled" /></p>
<h3 id="离屏渲染renderpass"><a class="markdownIt-Anchor" href="#离屏渲染renderpass"></a> <strong>离屏渲染RenderPass</strong></h3>
<p>离屏渲染的案例可以参考vulkan示例的bloom。</p>
<p>renderDoc调试观察bloom.exe, 这个程序被划分为了3个pass。colorpass(offscreen)→blur→scene。先对colorpass进行离屏渲染，然后将渲染结果blur模糊处理，最后在场景绘制中将离屏渲染的内容也绘制上。</p>
<p><img src="/images/games106homewrok1/Untitled%202.png" alt="colopass" /></p>
<p><img src="/images/games106homewrok1/Untitled%203.png" alt="gaussblur" /></p>
<p>对相关关系不是很熟练，所以如下图所示整理了一下bloom这个程序中的相关绑定，便于自己理解相关绑定。</p>
<p><img src="/images/games106homewrok1/Untitled%204.png" alt="" /></p>
<ol>
<li>
<p><strong>资源绑定</strong></p>
<p>首先需要对原先的数据结构进行修改。修改pipelines结构体，新增VkPipeline tonemap。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">struct</span> <span class="title class_">Pipelines</span> &#123;</span><br><span class="line">	VkPipeline solid;</span><br><span class="line">	VkPipeline wireframe = VK_NULL_HANDLE;</span><br><span class="line">	VkPipeline tonemap = VK_NULL_HANDLE;</span><br><span class="line">&#125; pipelines;</span><br></pre></td></tr></table></figure>
<p>对于新增的VkPipeline tonemap，也要创建一个VkPipelineLayout和VkDescriptorSet与之对应。同步更新对应的DescriptorSetLayouts结构体.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">struct</span> &#123;</span><br><span class="line">	VkPipelineLayout pipelineLayout;</span><br><span class="line">	VkPipelineLayout postPipelineLayout;</span><br><span class="line">&#125; pipelineLayouts;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> &#123;</span><br><span class="line">	VkDescriptorSet descriptorSet;</span><br><span class="line">	VkDescriptorSet postDescriptorSet;</span><br><span class="line">&#125; descriptorSets;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">DescriptorSetLayouts</span> &#123;</span><br><span class="line">	VkDescriptorSetLayout matrices;</span><br><span class="line">	VkDescriptorSetLayout textures;</span><br><span class="line">	VkDescriptorSetLayout post;</span><br><span class="line">&#125; descriptorSetLayouts;</span><br></pre></td></tr></table></figure>
<p>在setupDescriptors()，需要设置后处理pass的descriptor layout，把后处理pass需要用到的资源绑定到流水线中。</p>
<p>对于新的tonemap pass，只需要将一张offscreen渲染得到的图片传给shader即可，不再需要uniform input。</p>
<p>mark：记得修改descriptor poolSizes。</p>
<p>在preparaPipeline()中，需要创建VkGraphicsPipelineCreateInfo去记录pipeline基本的信息。其中pipelineCI.pVertexInputState绑定了vertexInputStateCI，即vertex输入信息，它会和vertexInputAttributes联系起来，记录要传递到shader的输入信息。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  VkGraphicsPipelineCreateInfo pipelineCI = vks::initializers::<span class="built_in">pipelineCreateInfo</span>(pipelineLayouts.pipelineLayout, renderPass, <span class="number">0</span>);</span><br><span class="line">pipelineCI.pVertexInputState = &amp;vertexInputStateCI;</span><br><span class="line">pipelineCI.pInputAssemblyState = &amp;inputAssemblyStateCI;</span><br><span class="line">pipelineCI.pRasterizationState = &amp;rasterizationStateCI;</span><br><span class="line">pipelineCI.pColorBlendState = &amp;colorBlendStateCI;</span><br><span class="line">pipelineCI.pMultisampleState = &amp;multisampleStateCI;</span><br><span class="line">pipelineCI.pViewportState = &amp;viewportStateCI;</span><br><span class="line">pipelineCI.pDepthStencilState = &amp;depthStencilStateCI;</span><br><span class="line">pipelineCI.pDynamicState = &amp;dynamicStateCI;</span><br><span class="line">pipelineCI.stageCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(shaderStages.<span class="built_in">size</span>());</span><br><span class="line">pipelineCI.pStages = shaderStages.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>
<p>而tonemap pass不需要绘制模型，所以<strong>不需要额外的vertex输入</strong>，所以pipelineCI.pVertexInputState传入为emptyInputState。</p>
<p>此外，<strong>表面剔除应该被禁用</strong>。pipelineCI.pRasterizationState中的cull mode需要修改为VK_CULL_MODE_NONE。</p>
<p>绑定好要用到的资源后，在buildCommandBuffers()中将绘制模型的pass中的renderPass和framebuffer改为offscreenPass的renderPass和framebuffer，此时模型被绘制在offscreenPass的frameBuffer中，运行将不再显示。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renderPassBeginInfo.renderPass = offscreenPass.renderPass; </span><br><span class="line">renderPassBeginInfo.framebuffer = offscreenPass.frameBuffer;</span><br></pre></td></tr></table></figure>
<p>之后在buildCommandBuffers()中新增tonemap pass，可以直接参考bloom中的代码。令其framebuffer = frameBuffers[i]。renderPass = renderPass;。最后的绘制命令利用vkCmdDraw(drawCmdBuffers[i], 3, 1, 0, 0)即可。</p>
</li>
<li>
<p><strong>shader实现</strong></p>
<p>tonemap pass的 frag shader已经给出，vert shader可以直接参照bloom中的gaussblur实现。</p>
<p>下面记录一些我遇到的花时间解决的问题。</p>
<p>我的shader是hlsl实现，做出来是这个样子，百思不得其解…不清楚是怎么把第一个pass生成的而图像传入第二个pass输入中的。调试分析了下应该是tonemap pass的 frag shader中的Texture2D textureColor读取了绘制模型最后一个material的纹理。</p>
<p><img src="/images/games106homewrok1/Untitled%205.png" alt="" /></p>
<p>后续我将frag shader中space1修改为了space0，就能正确的绘制了。应该是原先的资源都被绑定到了逻辑寄存空间space1中，而新增的资源则是被绑定到默认的space0中。相关比较好的解释参考下面的链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/388534044?source_id=1005">D3D12 RootSignature</a></p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Texture2D textureColor : register(t0, space0);</span><br><span class="line">SamplerState samplerColor : register(s0, space0);</span><br></pre></td></tr></table></figure>
<p>下面是tonemap前后效果的对比截图。</p>
<p><img src="/images/games106homewrok1/Untitled%206.png" alt="before" /></p>
<p><img src="/images/games106homewrok1/Untitled%207.png" alt="after" /></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/07/06/PBR%20Material%20e973a3d0689744b4b0f4947a1c40bd54/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/06/PBR%20Material%20e973a3d0689744b4b0f4947a1c40bd54/" class="post-title-link" itemprop="url">PBR材质理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-06 14:56:37" itemprop="dateCreated datePublished" datetime="2023-07-06T14:56:37+08:00">2023-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 18:22:57" itemprop="dateModified" datetime="2023-07-11T18:22:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Render/" itemprop="url" rel="index"><span itemprop="name">Render</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="pbr-material"><a class="markdownIt-Anchor" href="#pbr-material"></a> PBR Material</h1>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137013668">草履虫都能看懂的PBR讲解（迫真）</a></p>
<p>先前看了很多遍类似的了，结合《Unity Shader 入门精要》中的内容整理了下便于以后理解，以后有补充再添加。</p>
<hr />
<hr />
<p>光与材质相交会发生<strong>散射和吸收</strong>，散射改变光的方向，吸收改变光的能量。</p>
<p>在均匀介质中，光沿直线传播。传播过程中材质的折射率变化，光的传播方向也会发生变化，介质边界折射率突变，光会发生散射现象。</p>
<p>实际光和物体交互非常复杂，光沿直线传播也只是一种特例。介质的表面是不平滑的，由很多的微表面构成，微表面折射的光被折射到物体内部，一部分被物体吸收，一部分被重新散射到物体外部。对于金属材质，折射的光往往会被立刻吸收，对于非金属材质，折射到物体外部的光又被称为<strong>次表面散射光</strong>。</p>
<p><img src="images/PBR%20Material%20e973a3d0689744b4b0f4947a1c40bd54/Untitled.png" alt="Untitled" /></p>
<p>渲染建模中，会考虑两个介质的边界无限大且光学平滑。在此前提下，光在不同介质边界会被划分为两个方向：散射和折射。</p>
<h2 id="双向反射分布函数brdf"><a class="markdownIt-Anchor" href="#双向反射分布函数brdf"></a> 双向反射分布函数BRDF</h2>
<p>一般用<strong>辐射率</strong>去量化光。辐射率L是单位面积，单位方向上的光源辐射通量。评估光线的颜色和亮度。</p>
<p>计算光线与物体交互后的出射辐射率，需要使用BRDF计算。</p>
<p>当光线随着入射方向I到达表面某点时， <strong>BRDF=f(I,V)</strong> 表示了有多少能量被反射到了观察方向V上。</p>
<p>观察方向上的某个点出射辐射率等于所有入射辐射率叠加运算的结果。</p>
<p>由此引出<strong>反射等式：</strong></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>I</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>I</mi><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_0=\int_{\Omega}f(I,v)*L_i(I)*(n \cdot I)d\omega_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.27195em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.433619em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>BRDF表示了入射光线在观察方向上的权重分布。（n.I）表示f(I,v)*Li在材质表面的投影结果。渲染过程中采用的是精确的光源，方向确定，大小无限小。可以简化反射等式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub><mo>=</mo><mi>π</mi><mi>f</mi><mo stretchy="false">(</mo><mi>I</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>c</mi><mrow><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msub><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_0=\pi f(I,v)*c_{light}*(n \cdot I)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751388em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span></span></p>
<p>BRDF决定了着色是否基于物理，需要满足交换律和能量守恒定律。基于这些理论，BRDF可以用于描述<strong>表面反射</strong>和<strong>次表面散射</strong>。其中表面反射被成为<strong>高光反射项</strong>，次表面散射被称为<strong>漫反射项</strong>。</p>
<h2 id="漫反射"><a class="markdownIt-Anchor" href="#漫反射"></a> 漫反射</h2>
<p>最简单的Lambert 模型中Lambertian BRDF表示为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mrow><mi>L</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>s</mi><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><mi>I</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>c</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mi mathvariant="normal">/</mi><mi>π</mi></mrow><annotation encoding="application/x-tex">f_{Lambst}(I,v)=c_{diffuse}/\pi
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span></p>
<p>假定漫反射在任何方向的强度相同。满足能量守恒定律的BRDF要求反射能量不能超过入射能量，BRDF在半球内积分为1，所以要除Pi。（具体要好好思考下，关于能量守恒定律这点，书上有公式能很好的解释这点，就不多复述了）。</p>
<p>对于给定入射光方向的出射漫反射辐射::</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi></mrow></msub><mo>=</mo><msub><mi>c</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mi mathvariant="normal">/</mi><mi>π</mi><mo>∗</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_{diff}=c_{diffuse}/\pi *L_i(I)*(n\cdot I)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span></span></p>
<p>一点补充：</p>
<p><img src="images/PBR%20Material%20e973a3d0689744b4b0f4947a1c40bd54/Untitled%201.png" alt="Untitled" /></p>
<h2 id="高光反射"><a class="markdownIt-Anchor" href="#高光反射"></a> 高光反射</h2>
<p><strong>微面源理论</strong>提出，物体表面是由很多人眼看不到的微面元组成的。微面元可以被认为是光学平滑的。</p>
<p>发生反射时，不同的微表面会把光线反射到不同方向，只有一部分为微面反射的光能够进入我们的眼睛，即表面。下图介绍了可能出现的反射情况。</p>
<p><img src="images/PBR%20Material%20e973a3d0689744b4b0f4947a1c40bd54/Untitled%202.png" alt="Untitled" /></p>
<p>h为I和v的半角矢向量，m为表面法线。</p>
<p><strong>法线分布函数NDF</strong>可以用于计算有多少比例的微面元满足m=h， <strong>阴影遮掩函数G(I,v,h)</strong> 用于计算满足m=h的微面元中有多少因为遮挡不被看到，给出了活跃微面元的所占浓度，活跃的微面元才能把光线反射到观察方向上。</p>
<p>Blinn模型中的法线分布函数是最简单的，而Unity中standard shader使用了GGX模型。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mrow><mi>b</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>h</mi><msup><mo stretchy="false">)</mo><mrow><mi>g</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>s</mi></mrow></msup></mrow><annotation encoding="application/x-tex">D_{blinn}(h)=(n\cdot h)^{gloss}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mrow><mi>G</mi><mi>G</mi><mi>X</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><msup><mi>α</mi><mn>2</mn></msup><mrow><mi>π</mi><mo stretchy="false">(</mo><msup><mi>α</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>h</mi><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">D_{GGX}(h)=\cfrac{\alpha^2}{\pi(\alpha^2-1)(n\cdot h)_2+1 }
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="mord mathnormal mtight">G</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.526em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">h</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<p>其中α=roughness^2。</p>
<p>阴影掩盖函数使用了GGX衍生的Smith-Schlick模型。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>I</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">G(I,v,h)=\cfrac{1}{((n\cdot 1)(1-k)+k)((n\cdot v)(1-k)+k) }
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.526em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<p>其中k=roughness^2/2。</p>
<p><strong>菲涅尔反射</strong>函数可以计算活跃的微面元会把多少光反射到观察方向上，表示了反射光线占入射光想的比例。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>I</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>F</mi><mn>0</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>F</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>⋅</mo><mi>h</mi><msup><mo stretchy="false">)</mo><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">F(I,h)=F_0+(1-F_0)(1-1\cdot h)^{5}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中F0为高光反射系数，可以理解为高光反射颜色。常常会受到材质金属性的影响。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 F0 = <span class="built_in">float3</span>(<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>);</span><br><span class="line">F0 = <span class="built_in">lerp</span>(F0, <span class="built_in">ALBEDO</span>(input.UV), metallic);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/06/26/UE4%E7%A0%B4%E7%A2%8E%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/26/UE4%E7%A0%B4%E7%A2%8E%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">UE4实现破碎效果</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-26 16:58:22" itemprop="dateCreated datePublished" datetime="2023-06-26T16:58:22+08:00">2023-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-13 19:39:48" itemprop="dateModified" datetime="2023-07-13T19:39:48+08:00">2023-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">游戏程序相关</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer"/>
> 重新整理先前本科做过的一些文档。
<p>老师特别不推荐直接使用插件去完成实验，所以写了很多，很啰嗦。</p>
<h2 id="一-实验要求"><a class="markdownIt-Anchor" href="#一-实验要求"></a> 一、实验要求</h2>
<p>目的：  熟悉Mesh的概念，能自由利用Mesh数据。<br />
要求：  编写一个脚本，实现对mesh的破碎效果。<br />
Dalao作品示例↓：（不是我的！！不是我的—）<br />
<img src="https://img-blog.csdnimg.cn/20210322192351691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /></p>
<h2 id="二-软件核心代码算法代码文本"><a class="markdownIt-Anchor" href="#二-软件核心代码算法代码文本"></a> 二、软件核心代码（算法+代码文本）</h2>
<p>我先是使用apex destruction插件试了一下做出破碎效果，然后自己手动又用代码做了一下破碎效果。下面是实验过程记录，因为不算对ue4界面很熟，所以可能写的很详细。</p>
<ol>
<li>使用插件制作破碎效果： 在ue4 StarterContent-&gt;Props文件夹里选中一个模型。<br />
<img src="https://img-blog.csdnimg.cn/2021032219261171.png" alt="" /><br />
在设置面板里找到插件位置，选中Apex Destruction插件，在已启用处勾选。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210322192659464.png" alt="" /><br />
选中一个静态网格体模型右键，点击“创建可破坏网格体”。</p>
<p>下面记录了一些我查到的参数作用：<br />
Voronoi控制碎块的数目，Fracture Material Desc控制碎块生成的随机性。<br />
“爆炸当量”能调整碎块之间的距离。<br />
<img src="https://img-blog.csdnimg.cn/20210322192720448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<img src="https://img-blog.csdnimg.cn/20210322192745448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
调节完毕后，点击“破碎网格体”得到效果如下的破碎。<br />
<img src="https://img-blog.csdnimg.cn/20210322192757648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
按照官网上的教程，我想要给破碎体添加内外材质。（顺便学一下怎么在UE4里面自己做材质）<br />
Ue4里制作简单材质的方法：<br />
右键创建新的材质，重命名后双击点开。此时应该是下面的界面。</p>
<p><img src="https://img-blog.csdnimg.cn/20210322192837810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
给材质添加constant和constant3Vector两个常量。<br />
<img src="https://img-blog.csdnimg.cn/20210322192855285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
Constant控制材质的粗糙程度，constant3Vector控制材质的颜色。<br />
<img src="https://img-blog.csdnimg.cn/20210322192925455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
因为材质要应用到骨架网格体上，所以需要勾选“使用骨架网格体选项”（后来我尝试了一下，不勾选也可以，u添加到骨架网格体上时ue4会自动给你勾上）<br />
<img src="https://img-blog.csdnimg.cn/20210322192945399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
材质创建好了以后给要可破碎网格体添加上，0号材质是外面的一层材质，1号材质是里面的一层材质。我想跟着官网做那种破碎以后里外颜色不同的效果，但是失败了，ue论坛里有人说这个插件有一点问题。</p>
<p>最后在主界面打开可破坏网格体的模拟物理和模拟命中事件。<br />
<img src="https://img-blog.csdnimg.cn/20210322193010926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
点击运行，得到效果如下：<br />
<img src="https://img-blog.csdnimg.cn/20210322193028393.png" alt="" /><br />
然后我又试着下载了模型，导入UE4进行破碎查看效果。<br />
UE4支持导入fbx和obj模型的导入，它会自动生成一些比如static mesh的文件，比较智能。<br />
<img src="https://img-blog.csdnimg.cn/20210322193043300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /></p>
<ol start="2">
<li>使用UE4代码和蓝图制作破碎效果：</li>
</ol>
<p>Ue4的点开模型的界面可以显示出这个模型的mesh顶点，但想要自己用代码访问获取它的顶点数据还是得费点功夫的，在ue4官方论坛上有大神写了获取mesh顶点数据的教程。<br />
<img src="https://img-blog.csdnimg.cn/20210322193159124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
找了很久的教程，获取mesh网格<strong>顶点数据的核心代码</strong>：（UE4的教程真的太少啦，这个还是科学上网到论坛上找到的）<br />
<img src="https://img-blog.csdnimg.cn/20210322193257274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
在UE4里Tick( )函数是每帧都会被调用的函数。<br />
接下来就要在Tick（ ）函数里把获取到的mesh顶点都画出来。<br />
<img src="https://img-blog.csdnimg.cn/20210322193314240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
运行一下，顶点找到的效果如下。红色的就是找到的顶点位置。<br />
<img src="https://img-blog.csdnimg.cn/20210322193331216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
在找到顶点以后。开始下一步操作。新建一个蓝图类fragment，给他设置添加上基本的static mesh 和material。并且在physics一栏勾选模拟物理。<br />
<img src="https://img-blog.csdnimg.cn/20210322193345776.png" alt="" /><img src="https://img-blog.csdnimg.cn/20210322193356569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
换了一个形状，现在更像破碎后的碎片了。<br />
<img src="https://img-blog.csdnimg.cn/20210322193428395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<strong>下面让它怎么碎我就找不到代码教程了，班里面一个做游戏的大佬教我用蓝图实现了，菜鸡落泪。</strong></p>
<p>下面打开MyBreakingActor类的蓝图编辑器，开始用蓝图写出MyBreakingActor类的break函数。它的执行过程是这样的：</p>
<ol>
<li>调用MeshData方法获取mesh顶点。</li>
<li>显示循环遍历获取的每一个顶点，在顶点位置处生成fragment。</li>
<li>循环执行完以后，销毁MyBreakingActor实例。其蓝图视图如下所示：<br />
<img src="https://img-blog.csdnimg.cn/2021032219354724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
设置完break函数后，给要碰撞的breakingActor添加碰撞capsule，同时给地面也添加碰撞体以实现碰撞事件的触发。这样就可以实现碰撞后破碎的效果了。<br />
<img src="https://img-blog.csdnimg.cn/20210322193606375.png" alt="" /><br />
右键单击世界大纲视图中的mybreakingactor类，在“添加事件”中选择“OnActorBeginOverlap”，这个函数的作用是在进入触发器时，触发事件。<br />
<img src="https://img-blog.csdnimg.cn/20210322193623643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
接下来开始设置关卡。<br />
新建对象mybreakingactor的引用，然后通过这个引用拉出一条线调用break函数。连接OnActorBeginOverlap和break函数（也就是触发OnActorBeginOverlap时调用break函数）。<br />
在break函数后连接UE4自带的函数“在位置处生成发射器”，添加粒子效果进去。<br />
选好Emitter Template，然后执行完了需要记得销毁粒子效果，当然可以把烟的效果留下来。完整的关卡蓝图流程图如下所示：<br />
<img src="https://img-blog.csdnimg.cn/20210322193647172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /></li>
</ol>
<h2 id="三-游戏运行效果截图"><a class="markdownIt-Anchor" href="#三-游戏运行效果截图"></a> 三、游戏运行效果（截图）</h2>
<p>使用插件apex destruction实现的效果：<br />
<img src="https://img-blog.csdnimg.cn/20210322193717174.png" alt="" /><br />
<img src="https://img-blog.csdnimg.cn/20210322193724992.png" alt="" /><br />
代码+蓝图实现的效果：<br />
以前视频的逐帧截图：（石头掉下来把鹿砸碎了）：<br />
<img src="https://img-blog.csdnimg.cn/20210322193835546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /></p>
<h2 id="四-实验心得"><a class="markdownIt-Anchor" href="#四-实验心得"></a> 四、实验心得</h2>
<p>惯例，还是记一下在实验过程中遇到的问题。<br />
因为用的是UE4，它有很厉害的破碎插件，（破碎这个功能在ue4里面好像就特别底层）所以我查找到的大部分教程基本上都是用插件就实现破碎。<br />
虽然用插件apex destruction破碎很简单，但毕竟我啥也不会，不试一下连插件也不会，就先试着用插件实现了一下破碎。</p>
<p>用插件做了一遍以后，接下来就是自己试着做一个破碎的效果了。</p>
<p>我检索了很久都找不到ue4怎么用代码访问StaticMesh顶点数据，我不熟悉StaticMesh类的数据结构，去找官方文档，ue4官方文档又写得太简短，对我这种小白实在太不友好。<br />
就这样做了好几天的无用功后，我偶然间在ue4论坛找到了一篇文章，才终于找到了访问StaticMesh顶点数据的方法。（还是论坛靠谱，大佬也多）</p>
<p>最后吐槽一下，UE4编译是真的慢，慢的我一怒之下都想买个内存条了。</p>
<p>UE4里的奇奇怪怪的报错：</p>
<p>1号选手：就突然不认识最基本的类了，我查了半天发现原来根本就不用理它，报这种错应该就是编译器抽了，可以编译成功的。<br />
<img src="https://img-blog.csdnimg.cn/20210322193919595.png" alt="" /><br />
2号选手：<br />
<img src="https://img-blog.csdnimg.cn/20210322193938990.png" alt="" /><br />
找到BuildConfiguration.xml文件，并且在里面修改关掉vs的Increment那个插件：<img src="https://img-blog.csdnimg.cn/20210322193959125.png" alt="" /></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/06/26/UE4%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9C%E7%82%B9%E5%87%BB%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/26/UE4%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9C%E7%82%B9%E5%87%BB%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">UE4鼠标悬停点击效果实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-26 16:56:20" itemprop="dateCreated datePublished" datetime="2023-06-26T16:56:20+08:00">2023-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-13 19:39:55" itemprop="dateModified" datetime="2023-07-13T19:39:55+08:00">2023-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">游戏程序相关</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer"/>
> 重新整理先前本科做过的一些文档。
<p>这个实验做的太艰难了，因为我的电脑已经不太能带的动UE4了，c++代码只要有错误，编译一次要20多分钟。</p>
<h2 id="一-实验要求"><a class="markdownIt-Anchor" href="#一-实验要求"></a> 一、实验要求</h2>
<p>目的：  3D Interaction。<br />
要求：  鼠标操作3D空间物体。<br />
必备：悬停高亮<br />
左键拖拽<br />
右键旋转<br />
作品示例↓：<br />
<img src="https://img-blog.csdnimg.cn/20210322194453170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /></p>
<h2 id="二-软件核心代码算法代码文本"><a class="markdownIt-Anchor" href="#二-软件核心代码算法代码文本"></a> 二、软件核心代码（算法+代码文本）</h2>
<p>实现响应用户输入的第一步：首先我们要新建一个自定义的pawn类MyPawn，并设置MyPawn，使之在游戏开始时能自动响应玩家输入。<br />
（Pawn 类提供了一个变量，可供我们在初始化时进行设置，从而为我们处理该内容。）<br />
<img src="https://img-blog.csdnimg.cn/20210322194523957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
添加以下代码到 AMyPawn::AMyPawn 。<br />
<img src="https://img-blog.csdnimg.cn/20210322194539346.png" alt="" /><br />
构建基础组件。<br />
<img src="https://img-blog.csdnimg.cn/20210322194554985.png" alt="" /><br />
这个变量被标记为 UPROPERTY ，所以可以在 虚幻引擎 中看到它。 这个变量很重要，因为它可以防止游戏启动时或项目或关卡的关闭和重新载入时的变量重置。<br />
在MyPawn类的头文件里面添加：<br />
<img src="https://img-blog.csdnimg.cn/20210322194649507.png" alt="" /><br />
在MyPawn类的cpp文件构造函数里面继续添加：<br />
<img src="https://img-blog.csdnimg.cn/20210322194703560.png" alt="" /><br />
（这部分代码是按着官方文档写的，它是要做实现玩家移动和右键改变相机视角。<br />
但是相机部分我自己后来没用到，因为我还是做了右键旋转物体而不是相机）</p>
<p>给项目添加操作映射：<br />
<img src="https://img-blog.csdnimg.cn/20210322194718633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
关于动作映射和轴映射，我查了一下具体有啥区别。在代码实现上最大的区别就是动作映射绑定的函数不能带参数，而轴映射需要参数。<br />
<img src="https://img-blog.csdnimg.cn/20210322194751412.png" alt="" /><br />
接下来把编译好的MyPawn类创建实例放到世界大纲地图中：<br />
<img src="https://img-blog.csdnimg.cn/20210322194805999.png" alt="" /><br />
<strong>下面开始依次实现实验要求的基本功能。</strong></p>
<p><strong>1. 鼠标左键拖动实现改变物体位置</strong><br />
前面已经实现了映射绑定，现在我们开始在绑定的函数里添加具体实现。<br />
实现思路：<br />
在点击鼠标左键的绑定函数里记录物体旧的位置：<br />
<img src="https://img-blog.csdnimg.cn/20210322194928344.png" alt="" /><br />
在每一帧都会被调用的函数里计算物体新位置并更改：<br />
<img src="https://img-blog.csdnimg.cn/20210322194943443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
接下来在世界大纲视图里选中要进行操作的物体，右键对它的staticmesh进行编辑，在资源编辑器里设置碰撞为复杂碰撞，如下所示：<br />
<img src="https://img-blog.csdnimg.cn/20210322195010240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
完成以上操作后运行，长按鼠标左键就可以拖动物体了。</p>
<p><strong>2.鼠标右键拖动实现物体旋转</strong></p>
<p>首先，先在之前按下鼠标右键绑定的函数startRotate里添加如下所示的代码。与移动鼠标思路一致，获取鼠标的当前位置和物体的当前旋转角度。<br />
<img src="https://img-blog.csdnimg.cn/20210322195100142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
查资料查到FRotator的三个属性，还有yaw，pitch，roll在空间坐标系的作用。<br />
<img src="https://img-blog.csdnimg.cn/20210322195117642.png" alt="" />Yaw绕z轴旋转，pitch绕y轴，roll绕x轴旋转。</p>
<p><img src="https://img-blog.csdnimg.cn/20210322195136948.png" alt="" /><br />
观察一下我自己的坐标系，调一下相机的位置，尽可能的让它正一点，比如zoy面正对屏幕，这样后面右键鼠标旋转时，它的旋转效果会好一点。</p>
<p><strong>实现思路：</strong><br />
实现思路跟左键移动类似。<br />
<img src="https://img-blog.csdnimg.cn/20210322195219482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
先写一段代码获得鼠标当前在世界中的位置然后算出每一帧中鼠标的位移量，然后用物体旧的旋转值加上适当处理过的（我这里是直接加上去的，我问了别人，有算线面角再处理的）鼠标位移量，达到新的旋转值。<br />
<img src="https://img-blog.csdnimg.cn/20210322195249846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
我试着调整了一下NewRotation的Yaw，Pich，Roll的值，发现鼠标的右键移动并不能很好的映射（就是它旋转的方向，它旋转的轴是它自己的轴，转是能转了，但效果可能不是你所期望的。）</p>
<p><strong>3.鼠标悬浮实现物体高亮</strong><br />
实现思路：<br />
自己试着按照官网文档新建一个发光的材质,然后把它添加到要变换的物体的staticmesh上。<br />
<img src="https://img-blog.csdnimg.cn/20210322195334895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
然后需要在检测到鼠标悬浮时，切换目标物体材质，检测到鼠标离开时，换回原材质。<br />
接下来在前面用到的碰撞检测函数的代码最前面添加如下代码：<br />
（这段代码的作用是当鼠标离开物体时恢复到物体以前的材质，取消高亮）<br />
<img src="https://img-blog.csdnimg.cn/2021032219535222.png" alt="" /><br />
在检测到碰撞物体不为空后，切换物体材质让它变成高亮材质：<br />
桌子的原本材质有两个，所以切换的材质统一使用静态网格体的最后一个材质。<br />
<img src="https://img-blog.csdnimg.cn/20210322195409553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
以上，编译运行即可。</p>
<p>补充一点：需要注意的的是编译运行之前，需要设置鼠标在play界面可见，不然运行的时候就看不到鼠标，把这一段代码添加到BeginPlay（）函数里：<br />
<img src="https://img-blog.csdnimg.cn/20210322195431315.png" alt="" /></p>
<h2 id="三-游戏运行效果截图"><a class="markdownIt-Anchor" href="#三-游戏运行效果截图"></a> 三、游戏运行效果（截图）</h2>
<p>效果截图（部分）：<img src="https://img-blog.csdnimg.cn/20210322195500392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /></p>
<h2 id="四-实验心得"><a class="markdownIt-Anchor" href="#四-实验心得"></a> 四、实验心得</h2>
<p>我觉得我快没有办法再用下去了。（绝望.jpg）<br />
只要代码有问题或是代码实现不太好，UE在Vs里编译一次就能花20分钟，在这期间我的浏览器，我挂在电脑上的qq，onenote，连我那个破输入法都变的奇卡无比。<br />
这可能已经不是“有点慢”的概念了。我真的没有办法理解为什么会那么慢，整个人心态都崩溃了。我打算再买个内存条装上看看，如果之后它还是这么慢的话，我都不知道以后工作量再大一点该怎么办，应该会照着教程直接用蓝图做了吧。<br />
这大概就是设备太烂的无能为力吧。</p>
<p>Ue4总体而言过程有点艰难，中文教程太少了。有教程的也全部都是蓝图的教程，代码的教程都是在它的英文论坛上一部分一部分找的。做这个的过程中，也问了走在我前面的人不少问题，在论坛试着找了很多英文教程，目前英语检索能力不太过关，走了不少弯路。</p>
<p>但最后实现出来了，虽然只是最基本的第一页功能，也着实不容易。</p>
<p><strong>惯例，还是记一下在实验过程中遇到的问题。</strong></p>
<p><strong>1.没有与参数列表匹配的 重载函数 “UInputComponent::BindAction” 实例</strong><br />
一直报这个错误，查了好久查不到解决方案，快自闭了。<br />
<img src="https://img-blog.csdnimg.cn/20210322195556212.png" alt="" /><br />
后来发现我绑定的几个函数是带参数的，我把参数去掉，就没报这个错了。<br />
<img src="https://img-blog.csdnimg.cn/20210322195615116.png" alt="" /><br />
<strong>动作映射不能带参数！！！轴映射要带参数。</strong><br />
<img src="https://img-blog.csdnimg.cn/20210322195644681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<strong>2.UE4崩溃</strong><br />
UE4崩溃有两种可能（我遇到的），第一种是代码里面有错误拿去编译运行，有一定几率崩溃。<br />
第二种是代码逻辑错误，比如数组越界，我在实现高亮换材质时遇到了这个。很坑，编译成功，一运行就崩，半天找不到哪错了。<br />
<img src="https://img-blog.csdnimg.cn/20210322195709603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<strong>3.鼠标悬浮（或许以后能用）</strong><br />
最开始想要实现悬浮效果，就试着用下面的代码绑定了文档里的OnBeginCursor还给它绑了自己新写的customOnBeginCursor。试了下效果，可以检测到鼠标悬浮，但是因为换材质要用到的变量挺多，就没有写在customOnBeginCursor里面。<br />
<img src="https://img-blog.csdnimg.cn/20210322195727591.png" alt="" /><br />
当鼠标光标移到此组件上并在播放器控制器中启用鼠标悬停事件时调用的事件<br />
<img src="https://img-blog.csdnimg.cn/20210322195741949.png" alt="" /><br />
这里面的参数UPrimitiveComponent类官网介绍这个是用于渲染数据，以后应该有机会用到，先码住。<br />
<img src="https://img-blog.csdnimg.cn/20210322195800527.png" alt="" /></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/06/26/unity%E6%97%A0%E9%99%90%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/26/unity%E6%97%A0%E9%99%90%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">Unity无限地形生成及玩家控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-26 16:47:07" itemprop="dateCreated datePublished" datetime="2023-06-26T16:47:07+08:00">2023-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-13 19:40:01" itemprop="dateModified" datetime="2023-07-13T19:40:01+08:00">2023-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">游戏程序相关</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <meta name="referrer" content="no-referrer"/>
> 重新整理先前本科做过的一些文档。
<p>这次实验主要实现了<strong>无限地形的生成</strong>和很常见的<strong>玩家控制</strong>，<strong>相机跟随</strong>，<strong>雾区设置</strong>，<strong>unity简单计时器的制作</strong>。<br />
素材都是直接在unity asset store 免费下载的。</p>
<h2 id="一-实验要求"><a class="markdownIt-Anchor" href="#一-实验要求"></a> 一、实验要求</h2>
<p>目的：户外场景构建。<br />
要求：构建一个户外开放世界游戏，为该游戏添加天空，地形，植物，并支持场景里自由漫游。<br />
沿着任意方向持续行走1分钟，不能跑到边界。</p>
<h2 id="二-软件核心代码算法代码文本"><a class="markdownIt-Anchor" href="#二-软件核心代码算法代码文本"></a> 二、软件核心代码（算法+代码文本）</h2>
<p>对于这次实验，我主要实现了 3个部分的内容，</p>
<h3 id="1脚本设置玩家的基本移动"><a class="markdownIt-Anchor" href="#1脚本设置玩家的基本移动"></a> <strong>1.脚本设置玩家的基本移动：</strong></h3>
<p><img src="https://img-blog.csdnimg.cn/20210322223404722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
同时给人物添加状态动画的切换，给人物添加了空格跳跃的功能：<br />
<img src="https://img-blog.csdnimg.cn/20210322223606521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<strong>实现部分核心代码：</strong><br />
<img src="https://img-blog.csdnimg.cn/20210322223643389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /></p>
<p>**中途遇见了一个比较琐碎的问题：**character controllor刚好与人物贴合（正好包裹人物），但是运行以后角色却总是飘浮在空中。<br />
<img src="https://img-blog.csdnimg.cn/20210322223713164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<img src="https://img-blog.csdnimg.cn/2021032222372638.png" alt="" /><br />
<img src="https://img-blog.csdnimg.cn/20210322223740457.png" alt="" /><br />
为了效果我把character controller的center位置调高了一点，然后又对Height进行了调节，这个地方我还是有点不懂，center既然是胶囊碰撞体与游戏对象的相对位置，为什么center位置明显调高后player才能正常落地呢？唯一的解释是player本身的位置就偏高了，但是我设置了重力，人物应该会落下….我有点搞不懂这是为什么，但是还是这样解决了。</p>
<h3 id="2设置相机平缓跟随人物移动"><a class="markdownIt-Anchor" href="#2设置相机平缓跟随人物移动"></a> <strong>2.设置相机平缓跟随人物移动：</strong></h3>
<p><img src="https://img-blog.csdnimg.cn/20210322223831141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<strong>实现部分核心代码：</strong><br />
<img src="https://img-blog.csdnimg.cn/20210322223923545.png" alt="" /></p>
<h3 id="3-构建一个户外开放世界天空盒雾区无限地形"><a class="markdownIt-Anchor" href="#3-构建一个户外开放世界天空盒雾区无限地形"></a> <strong>3. 构建一个户外开放世界（天空盒，雾区，无限地形）</strong></h3>
<p>（<strong>1）给当前scene添加一个天空盒</strong>，我在asset store下载了一些资源，然后直接把天空盒资源添加到了当前scene当中，效果如下所示。<br />
<img src="https://img-blog.csdnimg.cn/20210322223950263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
下一个地形资源，稍微做一下美化。<br />
用Terrain自带的笔刷把地形稍微刷一刷，方便测试。<br />
<img src="https://img-blog.csdnimg.cn/20210322224011254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
设置雾区。<br />
雾区可以再菜单栏Windows–&gt;Rendering–&gt;light settings中设置，如下图所示：<br />
<img src="https://img-blog.csdnimg.cn/20210322224036635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
然后给导进去的资源添加MoveTerrain代码，使其随人物的移动而移动。<br />
<img src="https://img-blog.csdnimg.cn/20210322224115283.png" alt="" /><br />
以上完成后效果如下：<br />
<img src="https://img-blog.csdnimg.cn/20210322224131474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<strong>（2）设置无限地形的生成：</strong><br />
关于怎么实现让人物在地面上跑一分钟，我想到两种方法：<br />
a.	实现思路1：<br />
让地形跟随着人物移动。检测到人物从地形中心移动超过地形宽度一半时，将整个地形也向前移动总宽度一半的距离。<br />
<img src="https://img-blog.csdnimg.cn/20210322224208402.png" alt="" /><br />
实现思路核心代码：<br />
首先对地形当前的位置及地形中心位置进行初始化，Terrain地形中心点的位置与其position中的位置有所不同，需要稍微简单算一下：<br />
<img src="https://img-blog.csdnimg.cn/20210322224222373.png" alt="" /><br />
先查看一下地形的长度和宽度：<br />
<img src="https://img-blog.csdnimg.cn/20210322224235208.png" alt="" /><br />
然后完成功能需要设置的变量：<br />
<img src="https://img-blog.csdnimg.cn/20210322224251703.png" alt="" /><br />
在界面中把地形要检测的玩家进行绑定：<br />
<img src="https://img-blog.csdnimg.cn/20210322224309724.png" alt="" /><br />
由于terrain的初始位置和中心位置是不一样的，我们用两个变量来分别记录他们。<br />
<img src="https://img-blog.csdnimg.cn/20210322224324530.png" alt="" /><br />
检测玩家的位置，并计算玩家与地形正中心的相对距离：<br />
<img src="https://img-blog.csdnimg.cn/20210322224340950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<strong>实现思路2：<br />
检测人物在当前地形中的位置，当玩家位置里地形块中心位置距离超过地形快总长的1/2时，新生成地形块，新地形块的位置相较于原地形向前了1/2个总长。<br />
上面提到的方法1有个漏洞：就是我只能沿着一个方向上跑1分钟。<br />
而现在这个方法可以让我在各个方向上跑不到头。</strong><br />
首先把地形设置为预设体prefab Terrain。<br />
<img src="https://img-blog.csdnimg.cn/2021032222443150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
在代码里面添加:<br />
<img src="https://img-blog.csdnimg.cn/20210322224443174.png" alt="" /><br />
既然要在场景中生成游戏物体，这句话的意思就是要获得要生成游戏物体myTerrain的引用。所以我们在预设里面绑定引用。<br />
<img src="https://img-blog.csdnimg.cn/20210322224502576.png" alt="" /><br />
现在开始我的代码实现，因为我只让触发条件时新生成一个预设实例，所以我用了一个deltaNx,deltaNz来记录变换量。（不用的话它就疯狂生成实例，然后卡死….）<br />
<img src="https://img-blog.csdnimg.cn/20210322224521859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
在初始的时候我的地形块是这样的：<br />
<img src="https://img-blog.csdnimg.cn/20210322224539681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
我横着跑（沿着x轴跑，之前只能沿着z轴）成功clone以后如下图所示!<br />
<img src="https://img-blog.csdnimg.cn/20210322224558975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
边界处的效果：<br />
<img src="https://img-blog.csdnimg.cn/2021032222461246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /></p>
<p><strong>（3）Unity 简易计时器的制作：</strong><br />
上课刚讲到UGUI。我就试着自己做一个简单的计时器练一练手。<br />
首先在scene里create选择UI，新建画布canvas，然后在canvas下新建Text 文本物体。<br />
<img src="https://img-blog.csdnimg.cn/20210322224721704.png" alt="" /><br />
关于文本Text的位置有下面的一点要注意，因为我的Terrain和player全部都在下面，我最开始时惯性思维把它放在左下角了，后来发现位置有问题：<br />
<img src="https://img-blog.csdnimg.cn/20210322224736578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
下面来给我的计时器添加代码，实现计时的功能：<br />
实现很基础，稍微声明一下时分秒变量，绑定游戏中的text，写一下进位法则即可，实现代码如下所示：<br />
<img src="https://img-blog.csdnimg.cn/20210322224752353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt="" /><br />
<em>关于Time.deltaTime的理解：</em><br />
Time.deltaTime 表示从上一帧到当前帧时间，以秒为单位。比如说每秒60帧，那么Time.deltaTime就是1/60秒。</p>
<h2 id="三-游戏运行效果截图"><a class="markdownIt-Anchor" href="#三-游戏运行效果截图"></a> 三、游戏运行效果（截图）</h2>
<p>效果截图（部分）：</p>
<p><img src="https://img-blog.csdnimg.cn/20210322224832200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjQyNzY1,size_16,color_FFFFFF,t_70" alt=" " /></p>
<h2 id="四-实验心得"><a class="markdownIt-Anchor" href="#四-实验心得"></a> 四、实验心得</h2>
<p>做实例化的时候出现了这个错误。</p>
<p><img src="https://img-blog.csdnimg.cn/20210322224917457.png" alt="" /></p>
<p>我查了一个小时，最后发现变量名敲错了，Terrain敲成Terrian了，被自己蠢哭。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/06/10/weather/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/10/weather/" class="post-title-link" itemprop="url">天光控制系统文档介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-10 14:46:55" itemprop="dateCreated datePublished" datetime="2023-06-10T14:46:55+08:00">2023-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 19:02:47" itemprop="dateModified" datetime="2023-07-11T19:02:47+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Weather/" itemprop="url" rel="index"><span itemprop="name">Weather</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-天光控制系统"><a class="markdownIt-Anchor" href="#1-天光控制系统"></a> 1 天光控制系统</h1>
<p>本文档会简单介绍天光控制系统中天气参数的获取与天体参数的计算，相关参数的调节效果等。</p>
<blockquote>
<p><strong>工作目标</strong><br />
天气控制系统负责根据APP的真实气象参数（云、能见度、天气气象、空气湿度、PM2.5、风力等），确实其余各系统（天光系统、云雾模型系统、粒子系统、特效渲染系统等）的参数。天气控制系统的功能包括：<br />
1. 手动指定或者从公开天气API的网站上自动下载当前某地的天气数据。<br />
2. 通过天气数据，根据一定的算法，生成各渲染模块需要的渲染参数。<br />
3. 当天气参数改变时，需要能够平滑处理渲染参数从旧值到新值的变化（制作一个逐帧插值的动画效果）。</p>
</blockquote>
<h2 id="11天气信息获取"><a class="markdownIt-Anchor" href="#11天气信息获取"></a> 1.1天气信息获取</h2>
<p>天气信息获取在WeatherHttp.cpp文件中。目前系统用到了百度国内天气API和百度普通IP定位API分别获取天气参数和地理经纬度信息。</p>
<p>百度国内天气API查询天气信息需要传入百度地理区域编码，这个编码目前存储在weather_district_code.xlsx中，现在简单的保留了杭州，宁波，乌鲁木齐三个城市便于测试。</p>
<p>目前获取到的天气json参数数据如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: 0,</span><br><span class="line">    &quot;result&quot;: &#123;</span><br><span class="line">        &quot;location&quot;: &#123;</span><br><span class="line">            &quot;country&quot;: &quot;中国&quot;,</span><br><span class="line">            &quot;province&quot;: &quot;浙江省&quot;,</span><br><span class="line">            &quot;city&quot;: &quot;杭州市&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;杭州&quot;,</span><br><span class="line">            &quot;id&quot;: &quot;330100&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;now&quot;: &#123;</span><br><span class="line">            &quot;text&quot;: &quot;多云&quot;,</span><br><span class="line">            &quot;temp&quot;: 8,</span><br><span class="line">            &quot;feels_like&quot;: 7,</span><br><span class="line">            &quot;rh&quot;: 81,</span><br><span class="line">            &quot;wind_class&quot;: &quot;2级&quot;,</span><br><span class="line">            &quot;wind_dir&quot;: &quot;西北风&quot;,</span><br><span class="line">            &quot;uptime&quot;: &quot;20230324202000&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;message&quot;: &quot;success&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="111天气参数"><a class="markdownIt-Anchor" href="#111天气参数"></a> 1.1.1天气参数</h3>
<p>天气控制系统会根据获取到的天气参数，映射到渲染参数上。详细的天气取值对照表可在百度官网资源下载处获得。 目前应用到的天气参数和对应渲染参数映射关系如下：</p>
<table>
<thead>
<tr>
<th>天气参数</th>
<th>描述</th>
<th>对应渲染参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>wind_class</strong></td>
<td>风力等级</td>
<td>wind_speed</td>
<td>i32</td>
<td>控制云运动的速度</td>
</tr>
<tr>
<td><strong>text</strong></td>
<td>天气现象</td>
<td>weather_status</td>
<td>i32</td>
<td>标识天气状态，如“晴”，“多云”等，根据不同的状态可以进行不同的配置。</td>
</tr>
</tbody>
</table>
<p>在如下详细代码中可对天气状态进行自由度比较高的配置。可以将某个状态下的渲染参数控制于特定的一个范围内，例如晴天和阴天状态下的云层。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case 0: //sunny</span><br><span class="line">    // exposure_new = random_f32(0.0028f, 0.0032f);</span><br><span class="line">    darkness_threshold_new = random_f32(0.1f, 0.15f);</span><br><span class="line">    // ...parameters for sunny</span><br><span class="line">    break;</span><br><span class="line">case 1: //cloudy</span><br><span class="line">    cloud_noise_lower_bound_new = random_f32(0.7f, 0.77f);</span><br><span class="line">     // ...parameters for cloudy</span><br><span class="line"></span><br><span class="line">// ....</span><br><span class="line"></span><br><span class="line">通过上述代码，可以根据不同的天气状态获取相应的渲染参数，其中晴天、阴天和下雨等状态具有不同的云层密度和厚度范围。在渲染过程中，可以使用获取到的参数来控制渲染效果，例如在绘制云层时，使用相应状态下的云层密度和厚度参数来调整云层的外观。通过灵活配置渲染参数，可以实现对不同天气状态下的渲染效果进行精确控制。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Remark</strong>：百度国内天气API的高级功能会以百分比形式提供云量信息，但控制云渲染的参数比较复杂，目前控制系统并未直接使用这项数据。</p>
</blockquote>
<h3 id="112调整动效"><a class="markdownIt-Anchor" href="#112调整动效"></a> 1.1.2调整动效</h3>
<p>当进行城市切换时，采用JobSystem来增加一些简单的参数调整动效，以提升用户体验。具体来说，通过以下方式实现了平滑的过渡效果：</p>
<ul>
<li>**使用smoothstep函数：**调用smoothstep函数来实现两个城市之间参数的平缓过渡。smoothstep函数是一种常用的插值函数，它将一个输入值（如时间或距离）映射到0到1之间的输出值，使得过渡更加平滑。通过适当调整smoothstep函数的输入参数，我们可以控制城市切换时动效的变化速度和平滑程度。</li>
<li>**参数调整动效：**通过JobSystem为城市切换过程添加了一些简单的参数调整动效。这些参数可能包括光照强度、天气效果、云层相关参数等，可以根据不同的场景和需求进行调整。通过在城市切换的过程中逐步改变这些参数，我们能够使过渡更加自然和流畅。</li>
<li>**Job List的运用：**为了避免城市切换过快导致过渡动画中断的问题，我们使用了Job List。在城市切换过程中，我们将所有需要处理的任务（例如加载新城市资源、卸载旧城市资源、更新参数等）添加到Job List中，并按照一定的优先级和顺序执行。这样可以确保在切换城市时，所有的过渡动画和相关任务能够按照正确的顺序和时间完成，避免中断和不连贯的效果。</li>
</ul>
<p>通过以上的扩展和优化，我们能够实现更加平滑和流畅的城市切换效果。用户在切换城市时将能够享受到更好的视觉体验，并获得更加真实和逼真的过渡动画效果。</p>
<h3 id="113参数调试"><a class="markdownIt-Anchor" href="#113参数调试"></a> 1.1.3参数调试</h3>
<p>调试信息用于验证和检查程序中关键数据的准确性和一致性。通过比较输出的城市、日期、位置、天气状态、日出日落时间和月相信息与渲染结果以及预期值进行对比，可以识别潜在的错误或异常。</p>
<p>开发人员可以使用断点调试、打印日志或调试工具来检查这些信息，以确保程序正确处理和显示相关数据。这些调试信息提供了关键的上下文和指导，有助于追踪问题并进行故障排除。</p>
<p><img src="/images/weather/1.png" alt="image" /></p>
<h2 id="12控制参数计算"><a class="markdownIt-Anchor" href="#12控制参数计算"></a> 1.2控制参数计算</h2>
<h3 id="121天体参数"><a class="markdownIt-Anchor" href="#121天体参数"></a> 1.2.1天体参数</h3>
<p>在该系统中，采用左手系作为世界坐标系。具体而言，X轴的正向表示东方，Y轴的正向表示上方，Z轴的正向表示北方。这种选择能够准确地描述和计算天体的位置和运动。以下是在Astronomy.cpp文件中进行的天体相关参数计算的几种类型：</p>
<ul>
<li><strong>经典的天文学模型计算</strong>：使用经纬度等数据进行计算，包括儒略日、儒略世纪和儒略日与年月日之间的转换。此外，还计算太阳时角和协调世界时(UTC)，以及其他相关的计算。这些计算基于经典的天文学模型，可用于精确确定时间和位置相关的天文参数。</li>
<li><strong>天文坐标体系下的参数矫正与计算</strong>：在天文坐标体系中，计算太阳赤纬、高度角、方位角等参数。为了获得准确结果，需要计算一些详细的参数，如真太阳时和平均太阳时差、太阳平均近角点和黄道的平均倾角等。这些计算有助于确定给定时间和位置上天体的精确位置和状态。</li>
<li><strong>Shader及调试所需参数计算</strong>：进行与着色器和调试相关的参数计算。例如，计算太阳和月球位置方向的公式，以及当前月相的计算。此外，还计算日出和日落的时间，以及结合日出和日落时间的曝光参数调控，实现在渲染过程中的自动曝光控制。</li>
</ul>
<p>在渲染过程中，使用这些计算得到的天体参数，主要涉及太阳方向、高度角、方位角和月亮方向等。这些值在计算完成后会传递给hlsl文件，供渲染管线使用。通过精确计算和使用这些天体参数，能够准确呈现太阳和月亮的位置、方向和相位等视觉效果。</p>
<table>
<thead>
<tr>
<th>天体参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>sun_dir</strong></td>
<td>Float3</td>
<td>太阳方向，天光渲染，体积云渲染使用</td>
</tr>
<tr>
<td><strong>sun_angle</strong></td>
<td>Float2</td>
<td>太阳高度角和方位角，天光渲染使用</td>
</tr>
<tr>
<td><strong>moon_dir</strong></td>
<td>Float3</td>
<td>月亮方向，夜晚月亮渲染使用</td>
</tr>
<tr>
<td><strong>moon_phase</strong></td>
<td>f32</td>
<td>月相，调试使用</td>
</tr>
</tbody>
</table>
<h2 id="13渲染参数调控指南"><a class="markdownIt-Anchor" href="#13渲染参数调控指南"></a> 1.3渲染参数调控指南</h2>
<p>在开发和调试过程中，我们发现实际数据并不一定能够直接展现出最佳的渲染效果。举例来说，有些资料显示云层主要存在于高度约在1500-4000米之间，但是在限制云层高度的情况下，系统绘制的远处云层可能显得比较薄，而增加整体云层的厚度则能获得更好的渲染结果。</p>
<p>除了天体方面的太阳和月亮位置参数之外，与天气相关的天光参数和体积云参数等，目前并没有固定的映射公式可供使用。为了实现曝光自适应和云层的高部erode（即云层上部的侵蚀效果），我们添加了简单的渐变函数。这样考虑到更好的呈现效果，各个参数都具备相当大的调整空间。</p>
<p>通过对各个参数进行调整，能够优化渲染效果，以更好地展现天气现象和云层的真实感。这意味着在开发过程中，我们需要仔细地调整各项参数，以便在视觉效果和实际数据之间取得最佳的平衡。通过对参数的灵活调整最终可以达到更加逼真的渲染结果。</p>
<p><img src="/images/weather/6ad29e499c3b6e1f3608f4ac0b614656.png" alt="image" /><br />
<img src="/images/weather/addea336c40d7a52e83116de3240d4a4.png" alt="image" /><br />
<img src="/images/weather/07415c6814cd4cac00260eee1fe60826.png" alt="image" /><br />
<img src="/images/weather/1a38b32f4e68efb975f5f1526c5b1989.png" alt="image" /></p>
<h3 id="131参数映射"><a class="markdownIt-Anchor" href="#131参数映射"></a> 1.3.1参数映射</h3>
<p><strong>1. 天光相关的渲染参数如下：</strong></p>
<table>
<thead>
<tr>
<th>渲染参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Month / Day</strong></td>
<td>i32</td>
<td>日期参数，不同月份，不同天数太阳和月亮的位置及月相有所变化</td>
</tr>
<tr>
<td><strong>Hour / Minute</strong></td>
<td>i32</td>
<td>时间参数，不同时间下太阳和月亮的位置，天光等有所变化</td>
</tr>
<tr>
<td><strong>View Height</strong></td>
<td>f32</td>
<td>相机Y坐标，不同海拔高度下的天光有所变化</td>
</tr>
<tr>
<td><strong>Camera Fov</strong></td>
<td>f32</td>
<td>相机视场角</td>
</tr>
<tr>
<td><strong>Ground Albedo</strong></td>
<td>Float4</td>
<td>地面反射率，影响天光和云层基础颜色</td>
</tr>
<tr>
<td><strong>Auto Exposure</strong></td>
<td>bool</td>
<td>是否开启自动曝光</td>
</tr>
<tr>
<td><strong>Exposure adapt Min</strong></td>
<td>f32</td>
<td>曝光调整最小值，在日落后对曝光值起主要调整作用</td>
</tr>
<tr>
<td><strong>Exposure adapt Max</strong></td>
<td>f32</td>
<td>曝光调整最大值，在日落前对曝光值起主要调整作用</td>
</tr>
<tr>
<td><strong>Stylized Kuwahara</strong></td>
<td>bool</td>
<td>是否开启kuwahara滤波后处理（油画风格滤镜）</td>
</tr>
<tr>
<td><strong>Saturability</strong></td>
<td>f32</td>
<td>画面饱和度调整，风格化采用更高的饱和度</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Kuwahara滤波</strong> Kuwahara算法进行后处理可以保持图像边缘，但是对内部进行色块化，这一点可以很好模拟不透明水彩的效果，参照下图效果。 Kuwahara计算偏移Offset时需要使用UV尺寸而不是像素尺寸，否则可能会出现渲染问题，在引擎集成Vulkan后Offset的类型变为int出现了一些bug，修改了Sobel Window使之更小缓解了渲染问题的出现。</p>
</blockquote>
<p><img src="/images/weather/b18afb9d56028a430bbf506ad1f8cd96.png" alt="image" /><img src="/images/weather/154160fa7cbf1c2009f2b3c52c9de4ea.png" alt="image" /></p>
<p><strong>2. 在夜晚情况下，天光相关的渲染参数如下：</strong></p>
<table>
<thead>
<tr>
<th>渲染参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Moon MSAA instead Moon spread</strong></td>
<td>bool</td>
<td>是否开启月亮MSAA</td>
</tr>
<tr>
<td><strong>Moon Size</strong></td>
<td>f32</td>
<td>月亮大小调整</td>
</tr>
<tr>
<td><strong>Star Intensity</strong></td>
<td>f32</td>
<td>星星亮度调整</td>
</tr>
<tr>
<td><strong>Min Radius</strong></td>
<td>f32</td>
<td>星星最小直径调整</td>
</tr>
<tr>
<td><strong>Radius Scale</strong></td>
<td>f32</td>
<td>星星直径缩放调整</td>
</tr>
<tr>
<td><strong>Glare Scale</strong></td>
<td>f32</td>
<td>星星眩光缩放调整</td>
</tr>
<tr>
<td><strong>MilkyWay Intensity</strong></td>
<td>f32</td>
<td>银河亮度调整</td>
</tr>
<tr>
<td><strong>Moisture</strong></td>
<td>f32</td>
<td>空气潮湿度，决定彩虹的强度，增大该值彩虹更明显</td>
</tr>
<tr>
<td><strong>Moisture Drop Radius</strong></td>
<td>f32</td>
<td>形成彩虹的散射水滴半径</td>
</tr>
<tr>
<td><strong>Use Lee Graph</strong></td>
<td>bool</td>
<td>彩虹是否使用Lee Graph</td>
</tr>
<tr>
<td><strong>Lens Flare Intensity</strong></td>
<td>f32</td>
<td>镜头炫光强度，增大时炫光强度增大</td>
</tr>
</tbody>
</table>
<p><strong>3.体积云相关的渲染参数如下，调节不同的效果需要下面多个参数联动：</strong></p>
<table>
<thead>
<tr>
<th>渲染参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ray_marching_step_count_sun</strong></td>
<td>i32</td>
<td>沿光照方向步进采样次数，影响云层明暗层次感。增大步进次数云层层次感增强</td>
</tr>
<tr>
<td><strong>ray_marching_step_count_view</strong></td>
<td>i32</td>
<td>沿视角方向步进采样次数。增大步进次数云层绘制细节增强</td>
</tr>
<tr>
<td><strong>blue_noise_factor</strong></td>
<td>f32</td>
<td>蓝噪声调控因子</td>
</tr>
<tr>
<td><strong>short_step_length_limit</strong></td>
<td>i32</td>
<td>步进最短长度限制</td>
</tr>
<tr>
<td><strong>cloud_noise_lower_bound</strong></td>
<td>f32</td>
<td>主要用于控制云量。增大后云量减少</td>
</tr>
<tr>
<td><strong>max_cloud_density</strong></td>
<td>f32</td>
<td>采样时云层密度限制，增大该值云层总密度增大。适当增大该值配合ray_marching_step_count_view的增大可获得形状更美观的云。</td>
</tr>
<tr>
<td><strong>edge_fading_effect_max_distance</strong></td>
<td>f32</td>
<td>Tile边缘虚化距离</td>
</tr>
<tr>
<td><strong>cloud_higher_bound_soften_factor</strong></td>
<td>f32</td>
<td>云层上边缘软化因子，增大该值可使云层上边缘软化</td>
</tr>
<tr>
<td><strong>cloud_lower_bound_soften_factor</strong></td>
<td>f32</td>
<td>云层下边缘软化因子，增大该值可使云层下边缘软化</td>
</tr>
<tr>
<td><strong>darkness_treshhold</strong></td>
<td>f32</td>
<td>云层暗部阈值，增大后暗部阈值增大，云层暗部亮度提高</td>
</tr>
<tr>
<td><strong>cloud_light_absorption</strong></td>
<td>f32</td>
<td>云层吸收光照程度调整，增大后云层暗部区域增大，整体亮度略微降低</td>
</tr>
<tr>
<td><strong>sun_light_scale_factor</strong></td>
<td>f32</td>
<td>太阳光照亮度调整，增大后云层整体亮度提高</td>
</tr>
<tr>
<td><strong>cloud_cover_range_front/back</strong></td>
<td>f32</td>
<td>云层覆盖范围，在Z轴方向上扩展</td>
</tr>
<tr>
<td><strong>cloud_cover_range_left/right</strong></td>
<td>f32</td>
<td>云层覆盖范围，在X轴方向上扩展</td>
</tr>
<tr>
<td><strong>cloud_noise_tiling_xyz (in meters)</strong></td>
<td>Float3</td>
<td>云层噪声Tile Size控制，配合cloud_noise_lower_bound和max_cloud_density等参数合理调整可获得不同形态效果的云</td>
</tr>
</tbody>
</table>
<h3 id="132参数预设"><a class="markdownIt-Anchor" href="#132参数预设"></a> 1.3.2参数预设</h3>
<p>为了更方便地展现渲染效果，控制系统已添加了参数预设的功能。这些预设参数存储在名为presets_data.xlsx的文件中，每个预设都记录了当前渲染效果所需的关键参数值。目前，系统保留了三种偏向动漫风格的参数预设，分别是kuwahara-day、kuwahara-dusk和kuwahara-night。</p>
<p><img src="/images/weather/377fdf88ef038e98f479fe165bea0193.png" alt="image" /><img src="/images/weather/52fee772f68d28cbcd3bcac8daeb76d7.png" alt="image" /><img src="/images/weather/bfb95bc2c4c374450641d754b7bf3578.png" alt="image" /></p>
<p>Styleized Kuwahara Presets</p>
<p>通过使用参数预设功能，用户可以轻松地选择不同的渲染风格，并快速应用与之相对应的参数设置。这样，无需手动调整每个参数的值，用户可以直接加载特定预设，从而实现所需的渲染效果。每个预设都经过精心设计，以确保渲染结果与所选择的风格相符。</p>
<p>在presets_data.xlsx文件中，每个预设都包含一组参数值，这些值可以直接应用于渲染管线中的相应参数。通过读取文件，系统能够快速访问和加载所需的预设参数，为用户提供便捷的操作体验。</p>
<table>
<thead>
<tr>
<th>name</th>
<th>hour</th>
<th>minute</th>
<th>auto exposure</th>
<th>exposure min</th>
<th>exposure max</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>kuwahara-day</strong></td>
<td>12.00</td>
<td>0.00</td>
<td>0.00</td>
<td>0.05</td>
<td>0.28</td>
<td>…</td>
</tr>
<tr>
<td><strong>kuwahara-dusk</strong></td>
<td>18.00</td>
<td>30.00</td>
<td>1.00</td>
<td>0.20</td>
<td>3.00</td>
<td>…</td>
</tr>
<tr>
<td><strong>kuwahara-night</strong></td>
<td>19.00</td>
<td>0.00</td>
<td>1.00</td>
<td>0.60</td>
<td>3.00</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>对于喜欢动漫风格的用户，kuwahara-day、kuwahara-dusk和kuwahara-night三种参数预设将为他们提供不同的渲染效果选择。这些预设经过精心调整，能够呈现出不同时间段的特定视觉效果，使用户能够在渲染过程中轻松实现所需的风格和氛围。</p>
<h1 id="2-天光渲染"><a class="markdownIt-Anchor" href="#2-天光渲染"></a> 2 天光渲染</h1>
<p>系统的天光渲染实现是基于论文《A Scalable and Production Ready Sky and Atmosphere Rendering Technique》。该论文提出了一种可扩展且适用于实际生产的天空和大气渲染技术，为系统的天光效果提供了重要的指导和实现思路。</p>
<p><img src="/images/weather/e8003f133845ac4b6cdbf958abef9e98.png" alt="image" /><img src="/images/weather/51f90ef6af5813d4b1cb26e8b8978e61.png" alt="image" /></p>
<p><img src="/images/weather/e69ae119a1514b1c4a268b7e747d39f0.png" alt="image" /><img src="/images/weather/7972388fcddfcedb5a736fd6e59b7940.png" alt="image" /></p>
<p>Sky in Different Height</p>
<p>根据论文的指导，系统采用了一系列先进的渲染技术和算法，以实现逼真的天空和大气效果。其中包括但不限于以下方面：</p>
<ul>
<li>大气散射模型：系统根据论文中的大气散射模型，考虑了大气中的气溶胶、颗粒物等因素，以及不同波长光在大气中的传播方式，从而模拟了逼真的散射效果。</li>
<li>光线追踪：系统使用光线追踪算法，通过模拟光线在大气中的传播和散射过程，计算出每个像素的天空颜色和亮度，从而实现了更加真实的天空效果。</li>
<li>渲染参数控制：系统根据论文中提供的渲染参数，可以对天光效果进行灵活的配置和调整。这使得用户可以根据需要，调整天空颜色、云层厚度、大气散射程度等参数，以获得满足需求的天光渲染效果。</li>
<li>多层次渲染：为了提高渲染效率和性能，系统采用了多层次的渲染技术。通过对场景进行分层和分块，系统可以针对不同层次的细节和可见性进行优化渲染，从而提供高效而逼真的天光效果。</li>
</ul>
<p>下面是部分相关纹理计算结果。</p>
<p><img src="/images/weather/ec2b77310db0d0051f37c52f12b49365.png" alt="image" /></p>
<p>SkyTransmissionLUT</p>
<p><img src="/images/weather/e2916b78000c2c446a9568aac62afa47.png" alt="image" /> <img src="/images/weather/485c816bb1f0f4cd188453482a191357.png" alt="image" /> <img src="/images/weather/8a623e6128fb20c89e5c6c7cd514c363.png" alt="image" /></p>
<p>SkyViewLUT in Different Time</p>
<h1 id="3-体积云渲染"><a class="markdownIt-Anchor" href="#3-体积云渲染"></a> 3 体积云渲染</h1>
<p>体积云渲染使用Volumetric Raymarching技术。在一些细节上参考了《Real-Time Volumetric Cloudscapes of Horizon Zero Dawn》中的技巧。</p>
<p>Ray marching通过迭代光线与云层相交的过程，结合密度和颜色的插值计算，以及考虑其他光照和环境因素，实现了体积云的渲染。这种方法能够捕捉云层的真实细节和光照效果，为逼真的云层渲染提供了一种有效的思路。</p>
<p>该方法首先需要定义一个表示云层密度三维纹理。然后，从摄像机位置出发，沿着每条光线逐步前进。在每个迭代步骤中，根据当前光线所处的位置，从三维纹理中采样相应的密度值。</p>
<p>接下来，需要确定光线是否与云层发生了相交。通过将当前光线的位置与采样到的密度值进行比较，如果密度值超过了一个预设的阈值，表示光线与云层发生了相交。</p>
<p>一旦发生相交，可以计算光线在相交点处的透射和散射效果，并根据云层的颜色信息来着色。这可以通过将相交点的密度值与预设的阈值进行插值来实现。通过这种方式，可以模拟光线在云层内部传播时的密度变化，从而实现光线的散射和吸收过程。</p>
<h2 id="31-相关噪声纹理生成"><a class="markdownIt-Anchor" href="#31-相关噪声纹理生成"></a> 3.1 相关噪声纹理生成</h2>
<h3 id="311-worley-perlin噪声"><a class="markdownIt-Anchor" href="#311-worley-perlin噪声"></a> 3.1.1 Worley-Perlin噪声</h3>
<p>为了模拟云层的外观变化，我们需要定义一个三维纹理。该纹理将在渲染过程中用于采样云层的密度和颜色信息。</p>
<p>生成具有Worley和Perlin噪声特征的纹理，按照FBM的方式进行不同频率的叠加，并将叠加的效果来对Perlin噪声进行调制（主要是进行膨胀），保留Perlin噪声整体形状的连接感。FBM算法的基本思路是，通过将不同频率不同振幅的噪声叠加到一起，来获得更为随机的噪声数据，生成的纹理用于创建自然景观、云层、纹理效果等。通过调整噪声频率和纹理大小等参数，可以获得不同风格和细节层次的纹理效果。</p>
<p>第一个3D纹理是一个具有4个通道的纹理，它在云层渲染中起到关键作用。</p>
<p>这个3D纹理具有128^3的分辨率，意味着它在三个维度上分别有128个采样点。它的分辨率足够高，可以捕捉到细微的细节和变化。</p>
<p>噪声在程序初始化时生成，参见CloudNoise.cpp中的generate_worley3d_noise函数。共生成了两张四通道的三维噪声，分辨率分别为$128^3$和$256^3$像素，高分辨率的噪声频率较低，低分辨率的噪声频率较高。噪声纹理中RGB通道存储了频率逐次翻倍的WorleyFBM噪声，A通道存储了Perlin-Worley噪声，参见CloudNoise.hlsl。</p>
<p><img src="/images/weather/657ab76858f1d2c4223300c57eae3bae.png" alt="image" /><br />
<img src="/images/weather/752398260c9e284cb052235d05182314.png" alt="image" /><br />
<img src="/images/weather/868cf4dbacef1ea788964c45efd02311.png" alt="image" /></p>
<p>这个纹理的第一个通道是通过Perlin-Worley噪声生成的。Perlin-Worley噪声结合了Perlin噪声和Worley噪声，产生了一种具有丰富细节和层次感的噪声模式。通过在不同的尺度和强度上组合这两种噪声，我们可以创建出具有自然随机性和变化性的形状。</p>
<p>除了第一个通道，纹理的其他三个通道是频率递增的Worley噪声。Worley噪声是一种基于点之间距离的噪声模式，它呈现出类似于细胞或颗粒的形态。通过在不同的频率上生成Worley噪声，并将其作为纹理的其他通道，我们可以在云层的基本形状上添加更多的细节和层次感。</p>
<p>这个3D纹理在渲染中被用来定义云层的基本形状。通过采样这个纹理并与其他参数相结合，我们可以控制云层的形态、起伏和纹理特征。这种标准方法可以为云层提供基本的形状结构，并为后续的细节添加和处理提供了基础。。</p>
<h3 id="312-curl噪声"><a class="markdownIt-Anchor" href="#312-curl噪声"></a> 3.1.2 Curl噪声</h3>
<p>为了模拟大气涡流的效果，在计算着色器中生成一个具有卷曲效果的curl噪声贴图。它通过使用噪音函数和位移函数来模拟云层的运动和形状变化。这种扭曲效果使得云层在视觉上更加动态和有生命力。通过调整旋度噪声的参数和与第二个纹理的叠加方式，我们可以控制湍流扭曲的强度和分布，使其与整个云层的形态和运动相协调。</p>
<p>该噪声在程序初始化时生成，参见CloudNoise.cpp中的generate_curl_noise函数，生成了一张$256^2$像素的二维噪声。着色器代码见CurlNoise.hlsl，实现方式是对二维的Perlin噪声求旋度。</p>
<p><img src="/images/weather/def299040063d36fba0cb31ad97fc8d2.png" alt="image" /></p>
<p>通过以上噪声的应用，我们能够更好地模拟云层的真实外观和运动，使观察者在场景中感受到大气中云朵的演化和变化。这样的细节和效果增强了渲染的真实性和沉浸感。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float2 <span class="title">curl</span><span class="params">(float2 p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">float2 result = <span class="built_in">float2</span>(**potential**(p + epsilon.yx), **potential**(p + epsilon));</span><br><span class="line"></span><br><span class="line">result -= **potential**(p);</span><br><span class="line"></span><br><span class="line">result /= epsilon.x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">float2</span>(-result.x, result.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="32-密度采样与光线步进"><a class="markdownIt-Anchor" href="#32-密度采样与光线步进"></a> 3.2 密度采样与光线步进</h2>
<h3 id="321-密度采样"><a class="markdownIt-Anchor" href="#321-密度采样"></a> 3.2.1 密度采样</h3>
<p>本项目以地球球心为原点，建立了空间直角坐标系，实现了一个云层密度函数，见CloudPass.hlsl中的sample_cloud_density函数，根据给定的世界空间xyz坐标，返回该位置的云层密度值。该函数的操作步骤如下：</p>
<ul>
<li>根据debug窗口设定的云层范围，令云层范围外的坐标返回0的云层密度</li>
<li>根据风速、风向和程序运行的时间，对采样坐标进行一定偏移，形成云被风吹动的效果</li>
<li>采样低频噪声，构造云层的基础形状</li>
<li>使用Curl噪声扭曲采样坐标，再使用扭曲后的坐标采样高频噪声，构造云层细节</li>
<li>使用高频噪声构造出的云层细节对基础形状进行侵蚀</li>
<li>重映射云密度值，令其不要超过debug窗口中设定的最大密度</li>
<li>对靠近云层边界的地方进行羽化</li>
<li>返回云密度值</li>
</ul>
<p>云层浓度采样步骤对云层的形状生成具有比较大的影响，也需要一定的细节调整，比如底部的云层比较稀薄，而上方的云层则凝结力度更高，需要根据采样的位置高度对采样值进行一定的调整。</p>
<p>详细细节调整见代码，云相关的多数参数在密度采样时都被应用。</p>
<h3 id="322-光线步进"><a class="markdownIt-Anchor" href="#322-光线步进"></a> 3.2.2 光线步进</h3>
<p>从摄像机位置开始，沿着每条光线逐步前进。在每个迭代步骤中，我们将根据当前光线所处的位置从三维纹理中采样相应的密度和颜色值。模拟云层密度和光线传输过程，考虑了大气颜色和环境光照等因素，计算光线经过云层后的光照能量，并将其应用于渲染目标，最终呈现出真实的云层效果。</p>
<p>光路如图所示。对于AB上的每个点P，我们在A-P-C上进行一次路径积分，计算光照累加的结果，见CloudPass.hlsl中的get_cloud_light_energy函数。光线步进的步骤如下：</p>
<ul>
<li>在计算着色器中根据线程id和屏幕分辨率计算出uv坐标</li>
<li>根据uv坐标计算出view向量，即图中的向量VA</li>
<li>view向量分别与海拔1500m、4000m的球壳求交，计算出交点A和B，这定义了光线步进的总距离；注意求交时根据摄像机的海拔高度进行分类讨论</li>
<li>在AB上进行第一个步进采样循环</li>
<li>每次循环中，根据采样点P的位置和light向量，求交计算出C点位置，并在光路PC上进行第二次步进采样循环</li>
<li>循环体中对云密度进行采样，并应用光照模型计算累加的光照效果</li>
<li>二重循环结束后，返回累加的radiance强度等结果</li>
</ul>
<p><strong>Remark：</strong> 为了获得更真实的云层效果，还考虑了其他因素，例如大气颜色和环境光照。这可以通过在每个迭代步骤中根据当前光线与云相交的位置（大气透视）以及地面反射率来调整颜色和光照效果。为了提高性能，可以采用一些优化技巧。例如，使用多层次采样减少光线迭代的步骤，并使用提前终止技术避免对远离相机的光线进行无用的迭代。*</p>
<p><img src="/images/weather/f3dd5fd3d7feffc40da85ff6576427dc.png" alt="image" /><br />
<img src="/images/weather/4a1a60f8577b3a7972f35fa7c2d85886.png" alt="image" /></p>
<p><img src="/images/weather/dcfd454d7e9327e5efe2a3b37b68269a.png" alt="image" /><br />
<img src="/images/weather/b9ab01ea36b61709d29860e848c04caf.png" alt="image" /></p>
<p>Volumetric Cloud Rendering</p>
<h3 id="323优化"><a class="markdownIt-Anchor" href="#323优化"></a> 3.2.3优化</h3>
<p><strong>1. Beer-Powder边缘优化</strong></p>
<p>《Real-Time Volumetric Cloudscapes of Horizon Zero Dawn》中提到了，在云层采样边缘优化中，采用Beer-Power Law可用于模拟和优化云层边缘的渲染效果。根据该定律，云层边缘处的光线在通过云层时会受到吸收和衰减，因此会产生边缘的透明度和柔和过渡效果。利用该定律可以调整光线的衰减程度，以使云层边缘看起来更加自然和真实。为了模拟真实的体积云效果，常常使用两次Henyey-Greenstein（HG）公式进行拟合，以获得所谓的&quot;银边效果&quot;。</p>
<p><em>Remark：Henyey-Greenstein公式是一种常用的散射模型，用于描述光在云中的散射行为。它基于物理原理，考虑了光线在云中的方向性散射。该公式通过一个参数g（称为相函数），表示了光线偏好朝向的方向，负责控制光线的散射方向性。当g接近1时，光线倾向于向前散射，而当g接近-1时，光线则倾向于向后散射。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*<span class="comment">// g discribe probability of scattering TODO*</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> **HenyeyGreenstein**(float3 light_dir, float3 view_dir, <span class="type">float</span> g = <span class="number">0.12</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> cos_theta = **dot**(**normalize**(light_dir), **normalize**(view_dir));</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.14159265358</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> - g \* g) / **pow**(<span class="number">1.0</span> + g \* g - <span class="number">2.0</span> \* g \* cos_theta, <span class="number">1.5</span>) / (<span class="number">4</span> \* pi);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在体积云的渲染中，第一次使用HG公式拟合用于模拟云层内部的散射行为，以产生散射光的效果。这有助于在云层内部形成柔和而均匀的光照效果。</p>
<p>而第二次使用HG公式拟合则用于模拟太阳光经过云层的散射行为，以实现&quot;银边效果&quot;。通过调整HG公式中的参数g，可以控制太阳光线的散射方向性，使得在云层边缘产生明亮的光环效果，这就是所谓的&quot;银边效果&quot;。该效果使云层的轮廓看起来更加明显、立体且逼真。</p>
<p>通过两次HG公式的拟合，结合合适的参数和光线模型，可以在渲染体积云时获得具有真实感和视觉效果的&quot;银边效果&quot;。</p>
<p>需要注意的是，实际应用中，云层边缘优化可能涉及更复杂的光线传输模型和算法，以考虑云层内部的多次散射和吸收。但Beer- Power Law为理论基础提供了一个起点，可用于探索和优化云层边缘的渲染效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Beer</span><span class="params">(<span class="type">float</span> cloud_density, <span class="type">float</span> light_absorption = <span class="number">0.5f</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exp</span>(-cloud_density \* light_absorption);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> **BeerPowder**(<span class="type">float</span> cloud_density, <span class="type">float</span> light_absorption = <span class="number">0.5f</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> powder_sugar_effect = <span class="number">1.0</span> - <span class="built_in">exp</span>(-cloud_density \* <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> beers_law = **Beer**(cloud_density, light_absorption);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> light_energy = <span class="number">2.0</span> \* beers_law \* powder_sugar_effect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> light_energy;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/weather/e1c8cfbc3606df32e499c2ad0af4efe6.png" alt="image" /></p>
<p>Beer-Lambert Law</p>
<p><strong>2. 动态步长</strong></p>
<p>光线步进开始时，默认为两倍步长；当前采样点云层密度大于0时，步长变更为一倍步长；当前采样点云层密度等于0时，记录下连续采样得到0密度的次数，如果连续采样密度为0超过8次（默认值），则步长改变为两倍。这是为了减少采样次数。该优化参见get_cloud_light_energy函数中no_cloud_flag布尔变量的变化。</p>
<p><strong>3. 下采样</strong></p>
<p>考察光照模型，式中R表示最终输出的radiance，LightScattered表示通过散射进入视线方向的光线，Transmittance表示视线方向上总云层厚度的透射率，background表示天空背景。其中需要使用光线步进进行计算的是L项和T项，因此我们把L和T单独保存到减半分辨率的纹理中，再与正常分辨率的天空背景进行混合，减少了四分之三的光线步进开销。L和T项参见CloudPass.hlsl中的结构体LightingResult；混合步骤参见CloudBlend.hlsl。</p>
<h3 id="324-采样技巧"><a class="markdownIt-Anchor" href="#324-采样技巧"></a> 3.2.4 采样技巧</h3>
<p>在屏幕右侧所看到的是一个相对于地平线高出约30度的旋转视角。使用标准方法在相机上方的区域绘制云层。</p>
<p>首先，我们通过采样第一个3D纹理来构建一个基本的云层形状。这个3D纹理包含了云层的外观信息。我们将采样得到的值与高度信号进行乘法运算，以控制云层的垂直位置和形状。通过这样的操作，我们可以创建一个基本的云层模型。</p>
<p>接下来的步骤是将这个基本的云层形状与覆盖率进行乘法运算。覆盖率决定了云层的密度和覆盖程度。通过调整覆盖率，我们可以控制云层的浓密程度和展现的面积。</p>
<p>此外，我们还会在云层底部降低密度。这意味着云层的底部会相对较薄，呈现出逐渐消散的效果。这样可以使云层在底部更加逼真，仿佛云朵正在形成或逐渐散开。</p>
<p>通过以上步骤，我们可以创建出更加逼真的云层效果，并使其与旋转视角相匹配，为观察者呈现出更加真实的云层场景。</p>
<p><img src="/images/weather/6b07333a84ff1d61f48cb5f6dbc63d8e.png" alt="image" /></p>
<p>Height-Sample Tricks</p>
<h1 id="4-夜空渲染"><a class="markdownIt-Anchor" href="#4-夜空渲染"></a> 4 夜空渲染</h1>
<h2 id="41月亮渲染"><a class="markdownIt-Anchor" href="#41月亮渲染"></a> 4.1月亮渲染</h2>
<p>系统通过天文运算，使用论文《A Physically-Based Night Sky Model》中提出的模型来计算出真实的月球方位。这个模型基于物理原理，考虑了多个因素如地球自转、地球公转、月球轨道等，以精确地确定当前时间的月球位置。</p>
<p>在系统的Debug窗口的Gizmos中，以黄色的方向指示当前时间的月球方位。这个指示器可以帮助用户准确地找到月球在天空中的位置。通过观察黄色指示器的方向，用户可以直观地了解到月球在特定时间的位置。</p>
<p>此外，系统还具有真实的月相功能。根据当前时间和月球的位置，系统可以精确地计算出月亮的相位，从而呈现出真实的月相。这使用户能够观察到月亮的圆盘是如何被太阳照亮的，从而获得更加真实和逼真的视觉体验。</p>
<p><img src="/images/weather/c479bff779006e643350be451ab8fac4.png" alt="image" /><br />
<img src="/images/weather/538922f02a72399d3efca95d0043d6f3.png" alt="image" /></p>
<h4 id="相关参数"><a class="markdownIt-Anchor" href="#相关参数"></a> 相关参数</h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Moon Size</code></td>
<td>用于Debug观察，调整月亮尺寸大小。</td>
</tr>
<tr>
<td><code>Moon Enable AA</code></td>
<td>开启月亮边缘反走样。</td>
</tr>
<tr>
<td><code>Moon MSAA Instead Moon spread</code></td>
<td>选择使用多重采样或边缘扩散的反走样方式，若关闭<code>Moon Enable AA</code>则不生效。</td>
</tr>
</tbody>
</table>
<h2 id="42夜空渲染"><a class="markdownIt-Anchor" href="#42夜空渲染"></a> 4.2夜空渲染</h2>
<h3 id="421星空"><a class="markdownIt-Anchor" href="#421星空"></a> 4.2.1星空</h3>
<p>根据输入的星空数据和参数，计算出每个顶点的位置、颜色和其他属性，并将结果传递给片段着色器进行渲染。涉及星空颜色的计算、坐标变换和一些参数的处理，用于实现星空效果的绘制。</p>
<h3 id="422银河"><a class="markdownIt-Anchor" href="#422银河"></a> 4.2.2银河</h3>
<p>通过计算每个像素的射线方向和透射值，在天空渲染过程中采样银河纹理并计算颜色，然后将银河颜色乘以透射值和银河强度，并将结果累加到目标纹理中的对应像素上。具体实现上，代码使用多线程并行计算的方式，根据相机参数和纹理采样，利用射线-球体相交检测和纹理采样的函数，进行天空渲染并生成最终的渲染结果。</p>
<p><img src="/images/weather/0dab56242e4aa0f84db284fc825bf36c.png" alt="image" /><br />
<img src="/images/weather/1d081d9f9bfab1226b7203c3194d244b.png" alt="image" /></p>
<h1 id="5-特效渲染"><a class="markdownIt-Anchor" href="#5-特效渲染"></a> 5 特效渲染</h1>
<h2 id="51彩虹特效"><a class="markdownIt-Anchor" href="#51彩虹特效"></a> 5.1彩虹特效</h2>
<p>对于观察者，彩虹的方向和太阳的方向是相反的。</p>
<p>彩虹的强度和色散分布受到空气中水滴的影响。系统中提供 <code>moisture</code> 参数来全局调整彩虹的颜色强度，以及 <code>Moisture Drop Radius</code> 调整发生散射产生彩虹的水滴半径。这两个参数也作为提供给控制系统的接口，便于与后续可能实际存在的天气环境参数进行关联。</p>
<p><img src="/images/weather/7d99e0ba020ac70321e7bb4b292b0fe8.png" alt="image" /><br />
<img src="/images/weather/abc201f6371ef5c3dd0d5ba13ea9de95.png" alt="image" /></p>
<p>当默认开启 “Use Lee Graph” 选项时，彩虹绘制会使用采样李氏图（Lee Diagram）的方式进行。李氏图是一种通过采样和插值来生成彩虹颜色序列的方法。它基于物理原理，考虑了光线折射和反射在水滴中的作用，以模拟出真实的彩虹效果。</p>
<p>然而，如果关闭了该选项，彩虹绘制将使用拟合的光谱进行，而不是基于物理的采样贴图。这意味着绘制彩虹时不再使用李氏图进行采样和插值，而是使用预先定义好的光谱数据来绘制彩虹。这种方法可以避免复杂的物理计算和采样贴图的开销，但在一些情况下可能会牺牲一定的真实性。</p>
<p>根据是否启用 “Use Lee Graph” 选项，彩虹绘制可以选择采用基于物理的采样李氏图方法或使用预先拟合的光谱数据进行绘制。前者可以提供更真实的彩虹效果，而后者则更加高效但可能略有牺牲真实性。</p>
<h4 id="空气湿度分布"><a class="markdownIt-Anchor" href="#空气湿度分布"></a> 空气湿度分布</h4>
<p>除了<code>moisture</code>对当前区域时间的全局空气湿度（彩虹强度）进行控制，系统中对空气湿度在海拔高度上的分布也进行了处理，随海拔升高呈先升高后衰减的趋势（如下图），当前设置为海拔2000m时达到最大值。因此在接近中午时，太阳方向与地面接近垂直，由于地面附近湿度较低，则无法看到彩虹；太阳靠近地平线附近时，能够比较容易地看到彩虹。</p>
<h4 id="相关参数-2"><a class="markdownIt-Anchor" href="#相关参数-2"></a> 相关参数</h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>moisture</code></td>
<td>环境湿度，全局调整彩虹颜色强度。</td>
</tr>
<tr>
<td><code>Moisture Drop Radius</code></td>
<td>发生散射的水滴半径，水滴半径小则为雾虹，偏向白色；水滴半径大则更容易产生衍射，彩虹各光谱颜色更清晰。</td>
</tr>
<tr>
<td><code>Use Lee Graph</code></td>
<td>是否使用李氏图进行彩虹绘制。</td>
</tr>
</tbody>
</table>
<h2 id="52镜头光晕特效"><a class="markdownIt-Anchor" href="#52镜头光晕特效"></a> 5.2镜头光晕特效</h2>
<p>当前系统实现了2D的SDF（有符号距离场）控制的镜头光晕形状， 也能够支持贴图调整。光晕效果通常是通过对场景中明亮区域的像素进行处理来实现的。</p>
<p>暂未提供直接调整镜头光晕样式的接口。下面是一种使用SDF实现镜头光晕的基本步骤：</p>
<ul>
<li><strong>提取明亮区域：</strong> 首先，需要确定哪些像素属于明亮区域，可以使用亮度阈值或色彩饱和度等方法来检测明亮像素。</li>
<li><strong>创建SDF纹理：</strong> 对于提取的明亮区域，需要创建一个SDF纹理，其中每个像素的值表示离最近边界的距离。这可以通过计算每个像素到最近边界的距离来实现。这个距离可以使用不同的方法计算，例如基于几何形状的距离计算或基于纹理的距离计算。</li>
<li><strong>SDF纹理采样：</strong> 将创建的SDF纹理应用于场景中的每个像素。通过采样SDF纹理，可以获取像素到最近边界的距离值。</li>
<li><strong>光晕形状控制：</strong> 使用SDF纹理的距离值，可以根据需要控制光晕的形状。可以根据距离值应用不同的光晕效果，例如径向渐变或环形渐变。较大的距离值通常对应着较强的光晕效果，而较小的距离值则表示较弱的光晕效果。</li>
<li><strong>光晕渲染：</strong> 最后，将计算得到的光晕效果与场景的原始图像进行混合，以实现光晕的呈现。混合的方式可以根据需求使用加法、乘法或其他混合模式。</li>
</ul>
<p><img src="/images/weather/8c6e54d8f8680e46db4b23a8f8ff1b63.png" alt="image" /><br />
<img src="/images/weather/0dce0b9aa56466a2e620588240ab4369.png" alt="image" /></p>
<h4 id="相关参数-3"><a class="markdownIt-Anchor" href="#相关参数-3"></a> 相关参数</h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Lens Flare Intensity</code></td>
<td>全局的镜头光晕强度</td>
</tr>
</tbody>
</table>
<h1 id="6-色调映射"><a class="markdownIt-Anchor" href="#6-色调映射"></a> 6 色调映射</h1>
<p>将HDR值精确映射到LDR是现代游戏渲染流程的重要组成部分。我们新渲染器的目标之一是用一种电影色调映射曲线替代Reinhard的映射曲线。我们尝试了Ucharted 2的一种曲线，并试着自己创建了一种曲线，但对这两种解决方案都不满意。最后，我们选择了ACES的曲线，它是Unreal Engine 4中默认的色调映射曲线。</p>
<p>ACES色彩编码系统旨在无缝处理彩色图像，无论输入或输出的颜色空间如何。它还包含了一个精心设计的电影曲线，用于在LDR输出设备上显示HDR图像。对于游戏来说，完全整合ACES可能有些过度，但可以只采样ODT（RRT（x））变换，并将简单的曲线拟合到这些数据上。我们甚至不需要运行任何ACES代码，因为ACES为所有变换提供了参考图像。尽管没有线性RGB D65 ODT变换，但我们可以使用REC709 D65，并从中去除2.4的伽马校正。 拟合曲线的HLSL源代码 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">float3 **aces_film**(float3 x)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a = <span class="number">2.51</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> b = <span class="number">0.03</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> c = <span class="number">2.43</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> d = <span class="number">0.59</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> e = <span class="number">0.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> **clamp**((x \* (a \* x + b)) / (x \* (c \* x + d) + e), <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>曲线是手动拟合的（最大适应误差：0.0138），以便在暗部更精确，毕竟之后我们还会应用一些伽马校正。此外，数据经过预曝光处理，所以输入为1时，输出约为0.8，从而使得结果图像的亮度与没有任何色调映射曲线的图像更加一致。对于原始的ACES曲线，只需将输入（x）乘以0.6。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float3 **gamma_correction**(float3 color, <span class="type">float</span> gamma)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> **pow**(**abs**(color), <span class="number">1.0</span> / gamma);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/weather/53dd710c97581e0b0b826117806cb6a6.png" alt="image" /></p>
<p>Fitted curve plotted</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/06/10/%E7%BB%86%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/10/%E7%BB%86%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/" class="post-title-link" itemprop="url">细胞自动机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-10 14:37:17" itemprop="dateCreated datePublished" datetime="2023-06-10T14:37:17+08:00">2023-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-28 16:49:17" itemprop="dateModified" datetime="2023-07-28T16:49:17+08:00">2023-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BA%92%E5%8A%A8%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">互动媒体技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr />
<p>整理了本科一些小demo的文档。</p>
<hr />
<hr />
<h1 id="一实验选题"><a class="markdownIt-Anchor" href="#一实验选题"></a> <strong>一.实验选题：</strong></h1>
<ul>
<li>自己实现一种细胞自动机，用excel或任意编程方式，可尝试在以下方面进行拓展：
<ul>
<li>网格结构（六边形/其他形态）</li>
<li>邻域</li>
<li>计算规则</li>
<li>数值形式（标量/矢量/张量…）</li>
<li>可视化方式（静态/非静态）</li>
<li>其他</li>
</ul>
</li>
</ul>
<h1 id="二实验过程"><a class="markdownIt-Anchor" href="#二实验过程"></a> <strong>二.实验过程：</strong></h1>
<p>在网格结构为正方形细胞自动机的基础上，我尝试着使用matlab制作了一个网格结构为正六边形的细胞自动机。<br />
<img src="/images/cellular-automaton/1.png" alt="" /></p>
<ul>
<li>绘制正六边形蜂窝网络：<br />
要实现网格结构为正六边形的细胞自动机，首先先要绘制出正六边形蜂窝网络，这涉及到了一定的算法实现。</li>
</ul>
<p>实现网格结构为正六边形的细胞自动机的状态转移，运算过程中需要记录储存的数据有：</p>
<p><strong>1.细胞状态：0或1 ( 0代表生存，1代表死亡 )</strong></p>
<p><strong>2.细胞中心坐标：(x0, y0)</strong></p>
<p><strong>3.细胞六个边界点的坐标：(xi, yi) (i=1,2,3,4,5,6)</strong></p>
<p><strong>4.六个邻近细胞行、列号：( row, col )</strong></p>
<p>考虑到以上数值都是整型或是浮点型数值，我选择用数组这一数据结构对其进行处理。</p>
<p>下面的过程记录会对这些数据的处理按顺序进行简单的介绍。</p>
<h3 id="1-六边形网络算法简单介绍"><a class="markdownIt-Anchor" href="#1-六边形网络算法简单介绍"></a> 1 六边形网络算法简单介绍：</h3>
<p>对于正方形来说，要构成一个网格，我们只有一种方式，但是对于正六边形来说，我们有多种方式排列，如下图所示的有边朝上的flat topped和尖朝上的pointy topped基础形式。<br />
<img src="/images/cellular-automaton/2.png" alt="" /></p>
<p>而在边朝上flat topped和尖朝上的pointy topped这两种排列的基础上，又可以拓展出以下偏移坐标系。<br />
<img src="/images/cellular-automaton/3.png" alt="" /></p>
<p>在偏移坐标系中，最常见的方法是将每一行(或列)进行偏移。每一列被命名为col(q)，每一行被称为row®。如上图所示，我们可以选择偏移奇数行或者偶数行，也可以选择偏移奇数列或者偶数列。</p>
<h3 id="2-中心center点绘制"><a class="markdownIt-Anchor" href="#2-中心center点绘制"></a> 2 中心center点绘制：</h3>
<p>正六边形网络的排列具有高度的规律性，在绘制网络之前，我们可以先推算出每个正六边形的中心点位置并画出，然后再根据中心点绘制完整的正六边形。</p>
<h4 id="a-中心点初始化"><a class="markdownIt-Anchor" href="#a-中心点初始化"></a> a 中心点初始化</h4>
<p>首先我们设置正六边形的边长为1/2，如下图所示，左侧第一个正六边形的横坐标<strong>初始值</strong>可以设定为：<strong>0.5或1.25</strong>。<br />
<img src="/images/cellular-automaton/4.png" alt="" /></p>
<h4 id="b-位置推演"><a class="markdownIt-Anchor" href="#b-位置推演"></a> b 位置推演</h4>
<p>如下图所示，正六边形的边长不变，水平方向上中心点到下一个中心点的横纵坐标变化为：</p>
<p>水平方向上：$$x_{next}=x_{recent}+\frac{3}{2}$$</p>
<p>垂直方向上：$$y_{next}=y_{recent}+\frac{\sqrt{3}}{4}$$</p>
<p><img src="/images/cellular-automaton/5.png" alt="" /><br />
完成初始化和确定好推演规则以后，就可以编写代码先绘制出六边形网络的所有中心点了，如下图所示。<br />
<img src="/images/cellular-automaton/6.png" alt="" /></p>
<h3 id="3-六个边界点坐标计算"><a class="markdownIt-Anchor" href="#3-六个边界点坐标计算"></a> 3 六个边界点坐标计算：</h3>
<p>这里采用了flat topped类型的正六边形布局。</p>
<p>如下图所示，设置正六边形的边长为1/2，设正六边形的中心点坐标为(x,y),则它的六个边界点的计算如下图标注所示：<br />
<img src="/images/cellular-automaton/7.png" alt="" /></p>
<p>根据上一个步骤推演计算得到的中心点坐标，计算得出正六边形六个边界点坐标值，并且调用一下matlab中的patch函数进行多边形绘制：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch(<span class="built_in">reshape</span>(Cell(<span class="built_in">i</span>,<span class="built_in">j</span>,<span class="number">3</span>:<span class="number">8</span>,<span class="number">1</span>),[<span class="number">1</span>,<span class="number">6</span>]),<span class="built_in">reshape</span>(Cell(<span class="built_in">i</span>,<span class="built_in">j</span>,<span class="number">3</span>:<span class="number">8</span>,<span class="number">2</span>),[<span class="number">1</span>,<span class="number">6</span>]),<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;blue&#x27;</span> );</span><br></pre></td></tr></table></figure>
<p>效果如下图所示：<br />
<img src="/images/cellular-automaton/8.png" alt="" /></p>
<p>至此基础的绘图完成，但是我们还需要给每一个正六边形的位置进行行列编号处理，对于边界的正六边形还需要将其设置为非细胞。</p>
<h3 id="4-行列编号"><a class="markdownIt-Anchor" href="#4-行列编号"></a> 4 行列编号：</h3>
<h4 id="a-排除非细胞点边界点"><a class="markdownIt-Anchor" href="#a-排除非细胞点边界点"></a> a 排除非细胞点（边界点）：</h4>
<p>由于设定规则需要获得一个细胞周围细胞的状态，所以我们需要在整个界面边界设置一圈“非细胞”，以免计算时出现越界的情况。</p>
<p>对于下图网格的每个交点进行遍历，搜索该交点附近的2个网格的交点，并计算两个点之间的距离。当距离值符合一定限制时。如图所示的浅蓝色圆形为有效搜索范围，计算出大致的范围半径并判断当前正在搜索的正六边形的中心坐标是否在范围内。如果改正六边形周边六个相邻位置都有正六边形，那么它是细胞，反之不是。</p>
<p><img src="/images/cellular-automaton/9.png" alt="" /><br />
部分判断代码：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%黄色区域范围计算</span></span><br><span class="line">x_range = [<span class="number">1</span>,<span class="number">1</span>].* <span class="built_in">cos</span>(PI/<span class="number">3</span>* (<span class="built_in">i</span><span class="number">-1</span>)-PI/<span class="number">6</span>)* distance+ [<span class="number">-0.1</span> <span class="number">0.1</span>]+ Cell(i_center, j_center,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">y_range = [<span class="number">1</span>,<span class="number">1</span>].* <span class="built_in">sin</span>(PI/<span class="number">3</span>* (<span class="built_in">i</span><span class="number">-1</span>)-PI/<span class="number">6</span>)* distance+ [<span class="number">-0.1</span> <span class="number">0.1</span>]+ Cell(i_center, j_center,<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="b-行列号初始化设置"><a class="markdownIt-Anchor" href="#b-行列号初始化设置"></a> b 行列号初始化设置：</h4>
<p>如上图所示，在确定交点为正六边形中心点，调用循环遍历的过程中，把判定为细胞的六边形的行列号一同进行标注即可。</p>
<p>修改正六边形的边长大小，已达到连续状态的细胞自动机可视化。</p>
<ul>
<li>规则设定：<br />
每个细胞有两种状态-存活或死亡，每个细胞与以自身为中心的周围六格细胞产生互动。</li>
</ul>
<p>最基础的生存游戏设定的演变规则如下表所示：</p>
<h3 id="1-基础生命游戏规则"><a class="markdownIt-Anchor" href="#1-基础生命游戏规则"></a> 1 基础生命游戏规则：</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>条件</strong></th>
<th style="text-align:left"><strong>状态转变</strong></th>
<th style="text-align:left"><strong>模拟依据</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">当前细胞为存活状态时，周围低于<strong>2</strong>个存活细胞时</td>
<td style="text-align:left">细胞变成死亡状态</td>
<td style="text-align:left">模拟生命数量稀少</td>
</tr>
<tr>
<td style="text-align:left">当前细胞为存活状态时，周围有<strong>2/3</strong>个存活细胞时</td>
<td style="text-align:left">细胞保持原样</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">当前细胞为存活状态时，周围有<strong>3个以上</strong>的存活细胞时</td>
<td style="text-align:left">细胞变成死亡状态</td>
<td style="text-align:left">模拟生命数量过多</td>
</tr>
<tr>
<td style="text-align:left">当前细胞为死亡状态时，当周围有<strong>3</strong>个存活细胞时</td>
<td style="text-align:left">细胞变成存活状态</td>
<td style="text-align:left">模拟繁殖</td>
</tr>
</tbody>
</table>
<p>规则设定代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 演变部分代码           </span></span><br><span class="line"><span class="keyword">if</span> Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">1</span>)==<span class="number">1</span> &amp;&amp; (N_live&gt;<span class="number">3</span> || N_live&lt;<span class="number">2</span>)</span><br><span class="line">  Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">2</span>)= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">elseif</span> Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">1</span>)==<span class="number">0</span> &amp;&amp; (N_live==<span class="number">3</span> )</span><br><span class="line">  Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">2</span>)= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>按照以上规则进行随机初始化后，运行细胞自动机，最终的结果会演化呈现出几种稳定的结构：<br />
<img src="/images/cellular-automaton/a2.gif" alt="" /></p>
<h3 id="2-规则变更-扩散效果"><a class="markdownIt-Anchor" href="#2-规则变更-扩散效果"></a> 2 规则变更-扩散效果：</h3>
<p>规则设定：先把中间点置为1，每一时间步对每一点，如果周围六个点之和为偶数，则变为0，为奇数则变为 1。</p>
<p>规则设定代码实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 演变部分代码           </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(N_live,<span class="number">2</span>)==<span class="number">0</span></span><br><span class="line">  Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">2</span>)= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">2</span>)= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>按照以上规则进行初始化赋值设置中心点为1，运行细胞自动机，得到如下所示的效果：<br />
<img src="/images/cellular-automaton/a3.gif" alt="" /><br />
仔细观察其实也可以发现这就是分形效果的一种演变。更改初始化点的位置，可以获得不一样的效果实现，如图蓝色为初始化四个边界点为状态1的单独效果，黄色为累积叠加效果：<br />
<img src="/images/cellular-automaton/a4.gif" alt="" /><br />
<img src="/images/cellular-automaton/a6.gif" alt="" /></p>
<h3 id="3-规则变更-连续状态"><a class="markdownIt-Anchor" href="#3-规则变更-连续状态"></a> 3 规则变更-连续状态：</h3>
<p>更改了一下每个细胞中存储的状态值，现在细胞中存储的不仅仅是0或1任意一个整数值，而是0-1的任意一个浮点数数值了。</p>
<p>下面设计了一个比较随意的规则，缩小网格数便于调试与观察。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> N_live&gt;<span class="number">5</span> </span><br><span class="line">  <span class="keyword">if</span> Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="number">-0.1</span>&gt;<span class="number">0</span></span><br><span class="line">    Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">2</span>)= Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="number">-0.1</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> N_live&lt;<span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span> Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">1</span>)+<span class="number">0.1</span>&lt;=<span class="number">1</span></span><br><span class="line">    Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">2</span>)=  Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">1</span>)+<span class="number">0.1</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>研究了好久Matlab官网的colormap函数，终于弄明白了这个函数的机制，自己写了一下不同数值映射到colormap的颜色上的代码：（只用了10种颜色，颜色太多网格数也太多展示效果也不明显。）</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">color = colormap(bone(<span class="number">10</span>)); <span class="comment">%颜色映射</span></span><br><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>);  <span class="comment">%范围</span></span><br><span class="line">color_index = <span class="built_in">ceil</span>(x*<span class="number">9</span>+<span class="number">1</span>);</span><br><span class="line">idx=<span class="built_in">ceil</span>(Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">1</span>)/<span class="number">0.01</span>);</span><br><span class="line"><span class="keyword">if</span> idx&gt;<span class="number">100</span></span><br><span class="line">  idx=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">elseif</span> idx&lt;<span class="number">1</span></span><br><span class="line">  idx=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">c = color(color_index(idx),:);</span><br><span class="line">set(pic&#123;<span class="built_in">i</span>, <span class="built_in">j</span>&#125;,<span class="string">&#x27;FaceColor&#x27;</span>,c);</span><br></pre></td></tr></table></figure>
<p>测试效果如下所示：<br />
<img src="/images/cellular-automaton/a8.gif" alt="" /></p>
<h1 id="三实验结果展示"><a class="markdownIt-Anchor" href="#三实验结果展示"></a> <strong>三.实验结果展示：</strong></h1>
<p>基于以上的操作，自己对细胞自动机的规则设定和初始化进行了很多尝试，并且又挑选出了一些规律性强一点的变化进行展示：<br />
<img src="/images/cellular-automaton/a5.gif" alt="" /><br />
<img src="/images/cellular-automaton/a7.gif" alt="" /></p>
<p>挑选了一些状态值为连续的细胞自动机颜色变化的生成图出来（无聊的小李玩了半天= =）：<br />
<img src="/images/cellular-automaton/a11.gif" alt="" /><br />
<img src="/images/cellular-automaton/a9.gif" alt="" /></p>
<p>想到小律老师上课讲过的热传导示例程序，我决定改一下规则实现一下，尝试了以下的模板。<br />
<img src="/images/cellular-automaton/10.png" alt="" /><br />
mark一下关键规则设定代码：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">changed=Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">1</span>)*(<span class="number">-6</span>)*delta;</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="number">1</span>:<span class="number">6</span></span><br><span class="line">  <span class="keyword">if</span> Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, k+<span class="number">8</span>, <span class="number">1</span>)~= <span class="number">-1</span> &amp;&amp; Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, k+<span class="number">8</span>, <span class="number">2</span>)~= <span class="number">-1</span> <span class="comment">%非边界正六边形</span></span><br><span class="line">    changed=changed+Cell(Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, k+<span class="number">8</span>, <span class="number">1</span>), Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, k+<span class="number">8</span>, <span class="number">2</span>), <span class="number">1</span>, <span class="number">1</span>)*delta;  </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">2</span>)=Cell( <span class="built_in">i</span>, <span class="built_in">j</span>, <span class="number">1</span>, <span class="number">1</span>)+changed;</span><br><span class="line"><span class="keyword">end</span>           </span><br></pre></td></tr></table></figure>
<p><strong>实现效果</strong>（左边是过程动图，右边是最后的结果）：<br />
（好鲜艳，眼睛快被闪瞎了）<br />
<img src="/images/cellular-automaton/a10.gif" alt="" /><br />
<img src="/images/cellular-automaton/11.png" alt="" /></p>
<p>修改delta来个加速变化 ( =v= )!<br />
<img src="/images/cellular-automaton/a12.gif" alt="" /><br />
真好玩，收工！</p>
<h1 id="四参考链接"><a class="markdownIt-Anchor" href="#四参考链接"></a> <strong>四.参考链接：</strong></h1>
<p><a target="_blank" rel="noopener" href="https://www.redblobgames.com/grids/hexagons/">https://www.redblobgames.com/grids/hexagons/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33446100/article/details/108670505?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=1328641.36998.16156918933538867&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">https://blog.csdn.net/qq_33446100/article/details/108670505?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=1328641.36998.16156918933538867&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30522183/article/details/99658530?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase">https://blog.csdn.net/weixin_30522183/article/details/99658530?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Cedaroski/article/details/78761838?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-6.control&amp;dist_request_id=1328641.36998.16156918933538867&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-6.control">https://blog.csdn.net/Cedaroski/article/details/78761838?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-6.control&amp;dist_request_id=1328641.36998.16156918933538867&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-6.control</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangziluomu/article/details/70792799?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161581789716780265438431%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161581789716780265438431&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-70792799.pc_search_result_no_baidu_js&amp;utm_term=matlab%E8%AE%A9%E6%95%B0%E5%80%BC%E6%98%A0%E5%B0%84%E5%88%B0%E9%A2%9C%E8%89%B2">https://blog.csdn.net/yangziluomu/article/details/70792799?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161581789716780265438431%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161581789716780265438431&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>first_rank_v2~rank_v29-2-70792799.pc_search_result_no_baidu_js&amp;utm_term=matlab%E8%AE%A9%E6%95%B0%E5%80%BC%E6%98%A0%E5%B0%84%E5%88%B0%E9%A2%9C%E8%89%B2</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/06/10/%E5%88%86%E5%BD%A2%E5%8F%8A%E5%85%B6%E9%9F%B3%E9%A2%91%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%94%E7%94%A8%E5%91%88%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/10/%E5%88%86%E5%BD%A2%E5%8F%8A%E5%85%B6%E9%9F%B3%E9%A2%91%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%94%E7%94%A8%E5%91%88%E7%8E%B0/" class="post-title-link" itemprop="url">分形及其音频可视化应用呈现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-10 14:37:17" itemprop="dateCreated datePublished" datetime="2023-06-10T14:37:17+08:00">2023-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-28 16:49:48" itemprop="dateModified" datetime="2023-07-28T16:49:48+08:00">2023-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BA%92%E5%8A%A8%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">互动媒体技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr />
<p>整理了本科一些小demo的文档。</p>
<hr />
<hr />
<p>这次实验学习G站上一位大佬的作品，自己也尝试着将音频数据可视化与分形图形整合了一下。</p>
<p><strong>实现目标：</strong></p>
<p>读取音频数据到缓存，考虑用分析声音的音调，让音调和颜色对应起来。</p>
<p>给简单的分形图形添加填充颜色，构成更和谐一点的音乐可视化的动画。</p>
<h1 id="一效果展示"><a class="markdownIt-Anchor" href="#一效果展示"></a> 一.效果展示：</h1>
<p><strong>使用随机噪声，并使颜色均匀变化生成分形的变换效果：</strong></p>
<p><img src="/images/fractal/f1.gif" alt="" /></p>
<p><strong>读取音频数据，“李克勤 - 月半小夜曲 (清唱版).mp3”的前奏部分及清唱部分效果展示：</strong><br />
<img src="/images/fractal/f2.gif" alt="" /><br />
<img src="/images/fractal/f3.gif" alt="" /></p>
<h1 id="二可视化处理"><a class="markdownIt-Anchor" href="#二可视化处理"></a> 二.可视化处理：</h1>
<h2 id="1音频信号处理"><a class="markdownIt-Anchor" href="#1音频信号处理"></a> 1.音频信号处理：</h2>
<p>处理音频信号可以用processing的sound库或是minim库。这里用到的是minim库，我依照一般音频处理的核心流程制作了一个简单的图表，如下所示。<br />
<img src="/images/fractal/i1.png" alt="" /></p>
<p>我对照着minim库官网的文档我对一些函数的作用进行了标注，并分析了代码作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fft = <span class="keyword">new</span> <span class="title class_">FFT</span>(bufferSize, sampleRate);    <span class="comment">//快速傅里叶变换将时域上的数据流转换到频域</span></span><br><span class="line">fft.logAverages(fft_base_freq, fft_band_per_oct); <span class="comment">//两种方法将信号按频率划分成不同的band以方便后续的分析</span></span><br></pre></td></tr></table></figure>
<h3 id="1fftlogaverages"><a class="markdownIt-Anchor" href="#1fftlogaverages"></a> 1）fft.logAverages</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fft.logAverages(fft_base_freq, fft_band_per_oct); </span><br></pre></td></tr></table></figure>
<p>组成音频的信号的频率的范围取值从1到几万(e.g. 44100 Hz)不等（这个说法不严谨但暂这么认为），但要实时地分析几万个信号不太高效，而Minim提供了两种方法将信号按频率划分成不同的band以方便后续的分析，分别是：linAverages和logAverages，顾名思义，线性的和对数的。<br />
这里我使用了对数方法对频率进行划分。</p>
<h3 id="2fftwindowffthamming"><a class="markdownIt-Anchor" href="#2fftwindowffthamming"></a> 2）fft.window(FFT.HAMMING)</h3>
<p>频率划分完毕以后，我们需要对音频信号进行加窗，也就是一次仅处理窗中的数据。因为实际的语音信号是很长的，我们不能也不必对非常长的数据进行一次性处理。明智的解决办法就是每次取一段数据，进行分析，然后再取下一段数据，再进行分析。</p>
<p>这里使用Hamming方法加窗。</p>
<p>关于Hamming窗口：<br />
<img src="/images/fractal/i2.png" alt="" /></p>
<p>怎么仅取一段数据呢？一种方式就是构造一个函数。这个函数在某一区间有非零值，而在其余区间皆为0.汉明窗就是这样的一种函数。它主要部分的形状像sin（x）在0到pi区间的形状，而其余部分都是0.这样的函数乘上其他任何一个函数f，f只有一部分有非零值。</p>
<p>为什么汉明窗这样取呢？因为之后我们会对汉明窗中的数据进行FFT，它假设一个窗内的信号是代表一个周期的信号。（也就是说窗的左端和右端应该大致能连在一起）而通常一小段音频数据没有明显的周期性，加上汉明窗后，数据形状就有点周期的感觉了。</p>
<h3 id="3fftforward"><a class="markdownIt-Anchor" href="#3fftforward"></a> 3）fft.forward( )</h3>
<p>调用<code>FFT</code>对象的<code>forward</code>函数，得到频域结果以后就可以开始分析了。官网给出了示例代码写的很清楚，它提供的可视化就是一个循环取出每一个band的amplitude，然后将其映射到矩形的高度上。 它提供的可视化就是一个循环取出每一个band的amplitude，然后将其映射到矩形的高度上。<br />
<img src="/images/fractal/i3.png" alt="" /><br />
<strong>官网示例程序：</strong></p>
<p>我截取官网给出来的一段示例代码，试图分析出它的意图。下面代码对应的正好是图片中Linear Average Center Frequency部分的绘制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="type">int</span>( width/fftLin.avgSize() ); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fftLin.avgSize(); i++)</span><br><span class="line">&#123;  <span class="comment">//遍历fft频率分段的每一个频率段，只要有变换就会有avgSize</span></span><br><span class="line">   <span class="comment">// if the mouse is inside the bounds of this average,</span></span><br><span class="line">   <span class="comment">// print the center frequency and fill in the rectangle with red</span></span><br><span class="line">   <span class="keyword">if</span> ( mouseX &gt;= i*w &amp;&amp; mouseX &lt; i*w + w )</span><br><span class="line">   &#123;  <span class="comment">//获取这个频率段的中位数？（频率）</span></span><br><span class="line">      centerFrequency = fftLin.getAverageCenterFrequency(i);</span><br><span class="line">      fill(<span class="number">255</span>, <span class="number">128</span>); </span><br><span class="line">      text(<span class="string">&quot;Linear Average Center Frequency: &quot;</span> + centerFrequency, <span class="number">5</span>, height23 - <span class="number">25</span>); </span><br><span class="line">      fill(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//简单的鼠标悬浮交互，换颜色</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       fill(<span class="number">255</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// draw a rectangle for each average, multiply the value by       spectrumScale so we can see it better</span></span><br><span class="line">   rect(i*w, height23, i*w + w, height23 - fftLin.getAvg(i)*spectrumScale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2分形图像处理"><a class="markdownIt-Anchor" href="#2分形图像处理"></a> 2.分形图像处理：</h2>
<p><img src="/images/fractal/i4.png" alt="" /></p>
<p>绘制分形图像的核心在于递归这一部分的代码，而优化可视化的效果在于改善每一个分支的结构。我希望能够计算一个多边形的每个分支的坐标点，就需要先得到原多边形的边界点坐标，每条边中点的坐标，剩下两个点需要根据多边形的边数和分支中心点设定相对应的函数进行计算。</p>
<p>下面我挑选了相对简单的正方形画了个示意图。<br />
<img src="/images/fractal/i5.png" alt="" /></p>
<p>下面是关于分支对应坐标点计算的代码部分，计算完分支点需要的外围坐标后把计算出的这些坐标数据全部传输给子分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">outerPoints = points;</span><br><span class="line">midPoints = calcMidPoints();</span><br><span class="line">projPoints = calcStrutPoints();</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">if</span> ((level+<span class="number">1</span>) &lt; _maxlevels) &#123;</span><br><span class="line">      <span class="type">Branch</span> <span class="variable">childBranch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Branch</span>(level+<span class="number">1</span>, <span class="number">0</span>, projPoints);</span><br><span class="line">      myBranches = (Branch[])append(myBranches, childBranch);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; outerPoints.length; k++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextk</span> <span class="operator">=</span> k-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nextk &lt; <span class="number">0</span>) &#123; </span><br><span class="line">          nextk += outerPoints.length;</span><br><span class="line">        &#125;</span><br><span class="line">        PointObj[] newPoints = &#123;  <span class="comment">//分支的外围坐标点包括下面的类别</span></span><br><span class="line">          projPoints[k], midPoints[k], outerPoints[k], midPoints[nextk], projPoints[nextk]</span><br><span class="line">        &#125;;</span><br><span class="line">        childBranch = <span class="keyword">new</span> <span class="title class_">Branch</span>(level+<span class="number">1</span>, k+<span class="number">1</span>, newPoints);</span><br><span class="line">        myBranches = (Branch[])append(myBranches, childBranch);<span class="comment">//子分支</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用vertex函数递归的对每个分支进行绘制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drawMe</span><span class="params">()</span> &#123;</span><br><span class="line">  strokeWeight(<span class="number">4</span> - level); </span><br><span class="line">  beginShape();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; outerPoints.length; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nexti</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nexti == outerPoints.length) &#123; </span><br><span class="line">      nexti = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vertex(outerPoints[i].x, outerPoints[i].y);</span><br><span class="line">  &#125;</span><br><span class="line">  endShape(CLOSE);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; myBranches.length; k++) &#123;</span><br><span class="line">    myBranches[k].drawMe(); <span class="comment">//递归绘制分形分支</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三优化处理"><a class="markdownIt-Anchor" href="#三优化处理"></a> 三.优化处理：</h1>
<p>以上，理解了这个库的相关用法，我个人感觉显示出的图表中是能反应出声音的振幅（响度）和频率信息的。<strong>可以根据计算当前所有频率段的幅值均值象征此时音量的响度，同时再根据各个频段的声音的幅值大小，逐频段对我的分形图形进行不同的效果变换。</strong></p>
<p><strong>需要注意的是：以下频段 i 都是简写，实际操作是需要依次计算边界值频率的！没有确切的频率区间数据就没有办法对每个区间的数据进行个性化处理。</strong><br />
<img src="/images/fractal/i6.png" alt="" /></p>
<p>只列出我在第一个区段的处理代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//根据频段分组的可视化处理</span><br><span class="line">// 0 ***** 0 Hz - 86 Hz ***** //</span><br><span class="line">// 这一部分是极低频部分，人是发不出的这样的声音的</span><br><span class="line">int i = 0;</span><br><span class="line">_b = round(drawFreqArr[i] * 255);  //超低频部分能够影响颜色中的蓝</span><br><span class="line">if (_b &lt; 50) &#123;</span><br><span class="line">  _b = 50;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一点自己的理解：</strong></p>
<p><strong>音乐踩点：</strong></p>
<p>当某一个频段的幅值突然变得很大时，有可能此处正是这首曲子边奏的一个节点或是曲子的一个节奏点之一，这个时候可以考虑让分形效果出现一些比较明显的变化（比如说边长增加，多边形边数+1等等）让我们的可视化图像能够更好的“踩点”。</p>
<p><strong>音调变换可视化：</strong></p>
<p>而对于一个hamming窗口内不同频率区段的声音，我们也可以分别赋予其一定的权值，调整填充及画笔颜色的r g b值，这样就可以使在某一时刻听到的声音较尖锐时，分形图像颜色偏红调，听到的声音较低沉时，分形图像颜色偏蓝调。</p>
<p><strong>响度可视化：</strong></p>
<p>通过计算hamming窗口内不同频率区段幅度的均值，我们大致是可以确定这个时刻音频的响度大小并将其可视化的。</p>
<p>我查阅 了些资料，找到了一个人声以及常见乐器声对应频率的表格（如下），然后如上面的图所示挑选了一部分区段进行处理，发现其实效果不错。<br />
<img src="/images/fractal/i7.png" alt="" /></p>
<h1 id="四感想"><a class="markdownIt-Anchor" href="#四感想"></a> 四.感想：</h1>
<p>在可视化一些我下载好了的歌曲的时候，我意识到不是所有歌曲可视化效果都是好的。</p>
<p>对于比较纯粹单一的乐器声和人声清唱而言可视化的动画效果和音乐节奏是比较能对的上的。</p>
<p>但是对于有些歌曲，伴奏声比较杂乱且混合着人声，一旦混合音多了，短时间的频率均值和高低频率部分的变化就会很夸张…可视化出来的效果就特别的鬼畜，不太合心意。</p>
<p>如果频率分段太多，会导致整个程序太敏感…特别是多音段对上变化多端的人声数据，整个就鬼畜的不行。如果频率分段的太少，就会导致对每个段的处理措施不够，最后无法细化，达不到理想中的效果。我测试的时候，numZone一般会被划分为7或8时效果比较好一点。</p>
<h1 id="五参考链接"><a class="markdownIt-Anchor" href="#五参考链接"></a> 五.参考链接：</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/rkemenczy/fractal_music.git">https://github.com/rkemenczy/fractal_music.git</a>。</p>
<p><a target="_blank" rel="noopener" href="http://code.compartmental.net/minim/fft_method_freqtoindex.html">http://code.compartmental.net/minim/fft_method_freqtoindex.html</a></p>
<p><a target="_blank" rel="noopener" href="http://code.compartmental.net/minim/fft_method_logaverages.html">http://code.compartmental.net/minim/fft_method_logaverages.html</a></p>
<p><a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/db7fa9ef856a561252d36f5b.html">https://wenku.baidu.com/view/db7fa9ef856a561252d36f5b.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/363783672_202824">https://www.sohu.com/a/363783672_202824</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30662849/article/details/99762104?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=1331645.22847.16184862403303525&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">https://blog.csdn.net/weixin_30662849/article/details/99762104?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=1331645.22847.16184862403303525&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/06/10/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/10/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-10 14:37:17" itemprop="dateCreated datePublished" datetime="2023-06-10T14:37:17+08:00">2023-06-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://vv-carrot.github.io/2023/06/10/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vv-carrot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VV's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | VV's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/10/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/" class="post-title-link" itemprop="url">上帝视角看GPU</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-10 14:37:17" itemprop="dateCreated datePublished" datetime="2023-06-10T14:37:17+08:00">2023-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-28 17:22:30" itemprop="dateModified" datetime="2023-07-28T17:22:30+08:00">2023-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GPU/" itemprop="url" rel="index"><span itemprop="name">GPU</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>Graphics Pipeline</h1>
<p>本文为看龚大的系列视频 ·上帝视角看GPU·的笔记整理。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1P44y1V7bu/?share_source=copy_web&amp;vd_source=9cb509c01f95d263c750fa9816649bfe">上帝视角看GPU（1）：图形流水线基础_哔哩哔哩_bilibili</a></p>
<h1>1. 图形流水线</h1>
<h2 id="帧缓存"><strong>帧缓存</strong></h2>
<p>帧缓存是内存的区域，与显示器上每一个像素是一一对应的。</p>
<p>在帧缓存里，每32位（4字节）来表示一个像素。输出到显示器时alpha存值会被忽略。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled.png" alt="帧缓存与像素一一对应"></p>
<h2 id="显卡"><strong>显卡</strong></h2>
<p>显卡把帧缓存的内容输出到显示器上，是图像的搬运工，没有计算能力。</p>
<p>显卡的显示输出端口通往<strong>显示器</strong>，显示电路把帧缓存转换成输出信号。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%201.png" alt="显卡显示电路把帧缓存转换成输出信号"></p>
<h2 id="处理器PU"><strong>处理器PU</strong></h2>
<p>如果对图像的操作算法固定，只需要设置不同的参数就能够达到目的。</p>
<p>如果操作比较灵活，就需要用一个shader程序。在PU处shader处理的是像素，所以这里叫做<font color=red bold>pixel shader</font>。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%202.png" alt="PU处理像素"></p>
<h2 id="流水线流程"><strong>流水线流程</strong></h2>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%203.png" alt="图形流水线流程"></p>
<p><font color=red bold>T&amp;L </font>硬件变化和光照在早期的GPU中是固定流水线单元，为了灵活性进化成可编程单元，这就是vertex shader。</p>
<p><font color=red bold>primitive asserbler</font>是固定流水线单元，会把屏幕之外的图形裁剪掉，计算三角形三条边的表达方程等。</p>
<p>光栅化<font color=red bold>（rasterizer）</font>操作是固定操作，叫做<font color=red bold>固定流水线单元fixed Pipeline Unit。</font></p>
<p>shader单元<font color=red bold>（pixel shader）</font>叫做<font color=red bold>可编程流水线单元Programmable Pipeline Unit。</font></p>
<p><font color=red bold>output merger</font> 会根据深度判断哪个像素能够存活下来。也属于固定流水线单元。</br></p>
<ol>
<li class="lvl-3">
<p><strong>vertex buffer / index buffer</strong></p>
</li>
</ol>
<p>如图所示可以表示一个几何体。<br>
vertex shader 读入的数据可以根据需要用不同的格式保存，只处理一个数据单元。<br>
index buffer中记录的是vertex buffer 中点的index，即表示一条线。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%204.png" alt="vertex buffer 与 index buffer"></p>
<ol start="2">
<li class="lvl-3">
<p><strong>world / view / projection matrix</strong></p>
<ol>
<li class="lvl-7">world matrix：决定物体在空间中的位置，朝向，放缩。</li>
<li class="lvl-7">view matrix：物体在以摄像机位置为远点的世界里，表示摄像机能看到的一个空间。</li>
<li class="lvl-7">projection matrix： 调整摄像机的参数，视野宽窄，视域远近范围。经过该矩阵物体就在屏幕范围的空间中了，带有近大远小效果。</li>
</ol>
</li>
</ol>
<h1>2. 逻辑模块划分</h1>
<h2 id="传统图形（计算）流水线">传统图形（计算）流水线</h2>
<p>当处理的单元不是顶点也不是像素，而是一个图元，此时就需要geometry shader。</p>
<p>vertex shader 处理完vertexes之后，primitive 先被送入geometry shader。</p>
<p><font color=red bold><strong>geometry shader</strong> </font>的特点是单入多出，可以输出多个primitive。可以进行三角形变换位置，细分等，让gpu可以做非均匀输出这样更加灵活的任务。</p>
<p>geometry shader是可选的，可以完成整条渲染流水线，也可以直接把数据输出到内存<font color=red bold>（<strong>stream output</strong>）</font>。</p>
<p>因为非常灵活，硬件无法做各种假设，导致性能偏低。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%205.png" alt="geometry shader可选"></p>
<p>对于细分三角形，gpu在vertex shader 之后加入了<font color=red bold><strong>tellsellation</strong> </font>功能。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%206.png" alt="tellsellation细分和与其相关的shaders"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>**hull shader：**可编程。指定每个图元如何被细分。内部分成多少个，每条边分成多少段。</p>
</li>
<li class="lvl-2">
<p>**tessellatior：**固定算法细分。</p>
</li>
<li class="lvl-2">
<p>**domain shader：**根据细分参数计算细分后顶点信息。</p>
</li>
</ul>
<p><font color=red bold><strong>compute shader</strong> </font> 独立于流水线，使用gpu上的计算单元进行计算。输入输出都是内存，限制比图形流水线小。使得开发难度跟接近传统，门槛低了很多。</p>
<p>以上 <strong>vertex shader， hull shader，domain shader，geometry shader</strong> 的存在意义就是将几何数据进行变换和拆解，但他们都无法脱离输入的几何数据。如果要离开输入的几何数据，让GPU自己生成大量复杂的数据， compute shader 任意读写能够做这件事情，但不能够接入rasterizer，这个需求催生了<font color=red bold><strong>amplification shader</strong> </font>和<font color=red bold><strong>mesh shader</strong></font>。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%207.png" alt="amplification shader和mesh shader"></p>
<p>amplification shader 负责指定执行多少此mesh shader， mesh shader负责产生几何体。此时渲染的单元（输入）不再是图元，而是一小块网络，称为<font color=red bold><strong>meshlet</strong></font>。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%208.png" alt="LOD (level of detail)"></p>
<p>meshlet输入到amplification shader ，如果需要进一步处理，就送入mesh shader，产生富有细节的一堆图元。</p>
<h2 id="光线追踪流水线">光线追踪流水线</h2>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%209.png" alt="光线追踪流水线"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>ray generation shader：</strong> 生成光线。</p>
</li>
<li class="lvl-2">
<p><strong>intersection shader：</strong> 判定光线与物体是否相交。</p>
</li>
<li class="lvl-2">
<p><strong>any hit shader：</strong> 在光线打到物体时判定是否继续往前走。</p>
</li>
<li class="lvl-2">
<p><strong>closest hit shader：</strong> 光线打到物体最近点计算颜色。</p>
</li>
<li class="lvl-2">
<p><strong>miss shader：</strong> 光线没打到任何物体时计算颜色。</p>
</li>
</ul>
<p>GPU也添加了神经网络计算的Tensor core和视频编码解码的video codec。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2010.png" alt="GPU常见模块"></p>
<p>CPU为通用模块，而GPU则被分为了多个模块，各有各的特点和用途。（GPU这些流水线之间是不能相互调用的）</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2011.png" alt="GPU图形流水线模块"></p>
<p>使用图形流水线的典型是游戏方面的应用，使用计算流水线的是机器学习方面的应用。</p>
<h1>3. 部署到硬件</h1>
<p>eg. 如果一个GPU上有两个vertex shader ，四个pixel shader。那么理论上在顶点和像素工作量在1：2时能发挥最高效率（负载较为均衡）。</p>
<p>随着渲染内容和流水线越来越大，全部堆到硬件上，负载均衡迟早会出问题。</p>
<p>随着需求的发展，<font color=red bold> 统一shader架构 </font>出现了。它用同样的硬件单元来执行各种shader，不需要再区分vertex专用的硬件单元。引入调度器，动态的调度需要的对应的单元。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2012.png" alt="统一shader架构"></p>
<p><strong>单指令单数据流SISD：</strong> 类比红绿灯，指令为红绿灯，数据流为车道，一个红绿灯一个车道。</p>
<p><strong>单指令多数据流SIMD：</strong> 一个红绿灯多个车道，车道上的车方向相同。</p>
<p>CPU上的核是SISD的，带有一定的SIMD指令集作为补充，CPU的核数指的是一共有多少条路。CPU计算的延迟小. 相当于一辆轿车, 上车就开直奔目的地.</p>
<p>而提到GPU中的一个核，指的是SIMD中的一个通路（车道）。GPU核的通道宽度往往很大，逻辑上可以认为很多个GPU线程再同一个时刻总是执行同样的指令。这样的一组线程称为<strong>warp</strong> 或者<strong>wave</strong> 。 GPU计算的吞吐量大. 相当于一辆公交车,得花时间上人, 每一站还得停.</p>
<p>GPU的SIMD很宽,大部分晶体管用于计算, 少量用于控制.</p>
<p><strong>流处理器（SP）</strong> ：一组流处理器，加上控制器和片上内存等，成为一个功能相对完整的<font color=red bold><strong>stream multi-processor (SM).</strong> </font></p>
<p>SM是GPU上的主要组成部分, SM数量越多, GPU越高端.</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2013.png" alt="SP与SM，warp占用寄存器空间"></p>
<p><strong>分支分歧:</strong> GPU中的不同车道需要进行不同操作时, 如果有两个分支操作,就需要把两个分支操作都执行,每个分量从结果里选择一个然后抛弃另一个.</p>
<p><strong>用计算掩盖访存:</strong> (编程领域叫协程?) warp到达read环节时, 将其暂停,激活下一个warp执行, 当原先的warp数据read 完毕后,重新将其激活执行. 这样的调度使得GPU线程数量可以远远多于核的数量. CPU上的超线程也用到了同样的思路.</p>
<p>SM内部会有一个寄存器空间, 每个warp都会占用一部分用于局部变量等. 如果整个空间都占满了就无法调度更多warp, 即是访存实在无法被计算掩盖的情况, 会降低效率.</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2014.png" alt="用计算掩盖访存"></p>
<h1>4. 完整的软件栈</h1>
<p>在很久很久以前，程序需要通过操作系统提供的硬件端口读写，直接操作图形硬件。如果每个程序都需要对每个操作系统的每个硬件写一遍，开发效率非常低。人们自然用了抽象的思路，通过抽象形成公共接口层, 程序调用接口层需要告诉下面程序”做什么”,这就是<font color=red bold><strong>应用程序编程接口API.</strong></font></p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2015.png" alt="应用程序编程接口API"></p>
<p>API 程序只要针对图形 API 写一遍就行，几乎不必考虑操作系统和硬件的区别。图形 API 由硬件厂商实现，往下翻译成对硬件的操作。</p>
<p>对于不同API的不同实现,也存在大量的可以公用的部分, 于是API的实现又进行了分层,增加了抽象层 <font color=red bold><strong>设备驱动接口DDI</strong></font>, DDI以上位操作系统, 负责数据有效性检查,内存分配等. DDI以下是驱动,负责不同的硬件.</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2016.png" alt="抽象层 设备驱动接口DDI, DDI以上位操作系统, 负责数据有效性检查,内存分配等. DDI以下是驱动,负责不同的硬件"></p>
<p><strong>DXD3D:</strong> 跨厂商, 但是不跨平台. 在 windows XP 的时代，软件栈就和理想状况下一样，操作系统提供一个 D3D runtime，往上是API，往下是DDI，厂商提供一个内核态驱动，这个框架称为XDDI。</p>
<p>顺着时间纵向来看， API 发展趋势是变薄，把更多的事情交给程序去做，而不是 run time 和驱动，因为程序知道自己的意图，不需要让 API 去猜，这个改进结果就是执行效率更高。这几年出现的D3D12 和 vulkan 都是响应的这个趋势，这样的 API 显得更底层，而用它们来开发更像是在写驱动，要做大量的细节操作。一般来说， API 网上还有个渲染引擎的抽象层，可以把不同的 API 抽象成同样的接口，这就把新 API 使用麻烦的缺点抹平了，同时获得新 API 带来的效率优势。</p>
<h1>5. 图形流水线的不可编程单元</h1>
<h2 id="硬件构造光栅化">硬件构造光栅化</h2>
<p>对于 GPU 的图形流水线来说，最核心最重要的一个组件就是光栅化器，它的存在直接决定了 GPU 在实施渲染方面的优势，以至于很多时候光栅化就是 GPU 图形流水线的代称。</p>
<p>经过vertex shader之后，每个顶点上都有了转换后的属性，包括位置、法线、方向、颜色、纹理、坐标等。经过 primitive 三步了之后，来到光栅化阶段，转换成像素。所以光栅化这个操作本质上就是把三个顶点上的信息插值到这个三角形覆盖的每个像素上，交给 pixel shader。 primitive Assembler 和光栅化总是连在一起，因此成为了广义的光栅化器。下面的讲述会把这两部分合并起来描述算法。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2017.png" alt="图形流水线"></p>
<p>要完成这样的插值，常见的方法称为<font color=red bold><strong>扫描线算法</strong></font>。顶点上有一系列的属性，根据三个顶点的位置和属性变化的长度，可以算出这个三角形覆盖的区域里，从一个像素挪到右边或者下边，各个属性会改变多少，这称为 ddx 和 ddy。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2018.png" alt="扫描线算法"></p>
<p>对于一个三角形来说，属性的 ddx 和 ddy 都是常量，只要算一次就行。接着从最靠上的顶点开始，沿着轮廓一行一行往下走，每一行根据三角形轮廓就能知道应该从哪里开始到哪里结束。往右一个像素属性增加 1 次 ddx，往下一行，属性增加 1 次 ddy。这样扫描生成三角形覆盖的所有像素。</p>
<p>那么像素在什么情况下认为被三角形覆盖？这叫做光栅化规则。<strong>普通模式下，光栅化三角形看的是像素中心是否在三角形之内。光栅化线看的是线是否经过像素里一个菱形区域。</strong></p>
<p>另一种模式是只要沾到一点就算覆盖，这叫<font color=red bold><strong>保守式光栅化</strong></font>，常用于体素化的需求。比如前几年很热门的 s b o contracing，就用保守式光栅化来把整个场景变成体素的表达。</p>
<p>光栅化的算法有了，直接放到硬件上，就成了<font color=red bold><strong>立即式光栅化</strong></font>。这个做法很淳朴，用 ASIC 把刚才描述的算法变成硬连线。在算法完全固定的情况下， ASIC 的效率远高于 FPGA 和可编程单元。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2019.png" alt="光栅化线：看线是否经过像素里一个菱形区域"></p>
<p>光栅化生成的像素，经过流水线后面的几个阶段写入内存里的渲染目标，渲染目标可能是纹理，也可能是帧缓存。对于大三角形来说，这么做性能非常高，因为只要算一次 ddx， ddy 后面一路累加过去就行，可以不被打断的一直执行同样的操作。但是如果三角形层层叠叠，就得反复写入内存，带宽占用很大，功耗高。</p>
<p>对 PC 渲染的需求来说，只要性能高，功耗高一点也可以接受，所以往往会选择立即式光栅化的方案。</p>
<p>移动平台更看重的是性能功耗，比如果性能只有一半，但功耗只有 1/ 4，也会考虑采纳。于是移动平台上光栅化往往采用 <strong>tile base</strong> 方案，他把渲染目标划分成很多固定大小的tile，常见的是 32 * 32，每个 tile 包含一个列表，存有和这个tile相交的所有三角形列表。所以 <strong>tile base</strong> 的光栅化不再是一个三角形处理，而是一批处理。这样的 GPU 需要有一个片上内存充当 cache 的角色，不需要大，但访问速度远远高于内存。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2020.png" alt="片上内存充当 cache 的角色，访问速度更加快速"></p>
<p>对于每个tile，先会把渲染目标的对应区域载入 GPU 的片上内存，接着用扫描线算法把列表里的三角形都渲染上去，最后把片上内存里的结果存到渲染目标，然后开始处理第二个tile。不管三角形如何层层叠叠，每个 tile 每次对内存的读写总是只有 32 * 32 个像素，远低于立即式 （立即式是一次性处理载入的全部像素）。但因为一个三角形没法一直填充下去，会因为 tile 被打断。性能其实是降低的，只是相比之下功耗降得更多。这是在高通的 GPU 上跑出来。光沙化顺序图可以看到，每个 tile 大小固定，一个 tile 铺成了整个屏幕。为了让大家加深印象，这里举两个实际的场景比较一下。</p>
<p>立即式和 <strong>tile base</strong> 在工作流程上的区别。</p>
<p>同样是渲染两个三角形，第一种情况，把它们渲染到同一张纹里。第二种情况，把它们分别渲染到两张纹理。对于立即式来说，都是把三角形光栅化出去，两个三角形是不是到同一个纹理无所谓，操作是一样的，因此两者的性能和功耗区别可以忽略不计。这是立即式渲染的流程，对于 <strong>tile base</strong> ，这俩就很不一样了。</p>
<p>第一种情况，光栅化的流程是，第1个 tile 载入到片上内存，渲染 2 个三角形存到纹理。第2个 tile 载入到片上内存，渲染 2 个三角形存到纹理。以此处理完所有tile。第二种情况的流程就变成纹理 a 的第一个 tile 载入到片上，内存渲染三角形 a 存到纹理a，纹理 a 的第二个 tile 载入到片上，内存渲染三角形 a 存到纹理a，依次处理完纹理 a 的所有tile。纹理 b 的第一个 tile 载到片上，内存渲染三角形 b 存到纹理b，纹理 b 的第二个 tile 载入到片上。内存渲染三角形 b 存到纹理b，依次处理完纹理 b 的所有tile。</p>
<p>注意，在片上内存的操作非常快，访问内存里的纹理慢的多，而且耗电的多，因此第一种情况比第二种情况好的多。</p>
<p>继续往后看，光栅化产生的像素会进入 pixel shader，然后是 output merger，场景是存在遮挡的，近的会挡住远的。之前说过，这是<strong>在 output merger 里通过深度测试</strong>来完成。假设光栅化产生像素a，跑完后面的流程写入渲染目标，又在同一位置产生像素b，这里会产生两个问题，第一，如果像素 b 比像素 a 还近，那他跑完后面的流程之后会覆盖掉像素a，这使得像素 a 经过的 pixel shader 和 output merger 完全浪费了。</p>
<p>第二，如果像素 b 比像素 a 还远，也得等到运行了 pixel shader 进入 output merger 才能发现有遮挡才抛弃掉像素b，那么像素 b 的 pixel shader 也白运行了。能不能把深度测试从 output merger 挪到 pixel shader 之前，不总是可以的，因为 pixel shader不但能输出颜色，也能输出深度。如果光栅化产生的深度和 pixel shader输出的深度顺序不一致，在 pixel shader之前执行深度测试就会出错。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2017.png" alt="图形流水线参考"></p>
<p>为解决第二个问题， GPU 引入的功能称为 <font color=red bold><strong>early-Z</strong></font>。在渲染状态符合条件的情况下，系统会检查一下 pixel shader。如果不输出深度，不用 discard 丢弃像素，就启用 early-Z 像素，在进入 pixel shader之前提前进行一次深度测试，如果已经被挡住，就不往下走，直接丢弃掉。</p>
<p>在 tile based 光栅化上，有的 GPU 会有个称为 <font color=red bold><strong>TBDR 模式</strong></font>， tile based differ rendering TBDR 在开启深入测试的情况下，把光栅化插值得到的像素属性都写入片上内存，这时候不可见的像素就被抛弃了，只有可见的继续往下走，同时解决那两个问题。但它是无法独立存在的，也是要一系列条件都符合的情况下才能启用，否则退回到 tile base 的模式。</p>
<p>既然立即式性能高， tile base 性能功耗比高，能不能取长补短一下？</p>
<p>有的 Maxwell 之后的 media GPU 就采用了两者的结合，称为<font color=red bold><strong>tile cache</strong></font>，它的tile巨大， 256* 256 这个级别 cache 也很大，不光像素，还可以把tile需要的几何也载入cache。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2021.png" alt="tile cache"></p>
<p>这么做降低了内存访问性能和性能，功耗比都更高了。这里依然可以用一张光栅化的顺序图来看到这个情况。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2022.png" alt="tile cache光栅化顺序图"></p>
<h2 id="软件构造光栅化">软件构造光栅化</h2>
<p>软件构造不是只在 CPU 上运行，而是在 GPU 的可编程单元里运行。有些需求使得软件光栅化变得很重要。</p>
<ol>
<li class="lvl-3">
<p><strong>第一个需求：小三角形的光栅化性能。</strong> 在实际中，硬件光栅化的输出并不是一个像素，而是一个 2* 2 的像素块，这成为一个 quad 之内。每个像素都有邻居，于是可以在 pixel shader里获得任何变量的 ddx 和ddy，只要邻居一检就出来了。这四个像素如果有在三角形之外的，之后才会被丢弃。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2023.png" alt="硬件光栅化输出为quad"></p>
<p>对于大三角形来说，最多也就是边缘的像素存在浪费，但对于小于一个像素的三角形，这就浪费了 3/ 4。因此，对于大量三角形都小于一个像素的时候，构造一个以像素为单位的软件光栅化器可以避免浪费，性能反而更高。在UE5的Nanite就是这么做的优化。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2024.png" alt="对于较小的三角形存在较多的像素浪费"></p>
</li>
<li class="lvl-3">
<p><strong>另一个需求，在无法使用硬件光栅化的时候执行光栅化</strong>。典型的是英特尔在 08 年的 larrabee上面，没有常规的流式处理器，而是对了 48 个奔腾的 X86 CPU，加上很宽的SIMD 指令集，在那些 CPU 上执行的是一个特制的软件光栅化算法，自适应细分的 tile base光栅化。</p>
<p><font color=gray>（<strong>算法流程：</strong> 首先像普通的tile base的一样，把整个渲染目标分成一系列tile，但是每个tile较大，至少 64* 64，同样也是每个tile包含与它们相交的三角形列表。接着把这个tile等分成 16 个小tile，测试每个小tile和三角形的相交情况，完全覆盖了就全部填充，完全不相交就跳过。如果部分覆盖就把小tile再继续分成 16 个更小的tile，再次测试，以此类推，直到像素级别为止。每次都是进行宽度为 16 的 SIMD 计算。</p>
<p>后来larrabee项目停止，砍掉显示输出能力后改造成这样。泛运算卡那个 SIMD 指令集成了 ABX5 12，普遍猜测是功耗控制不住。）</font></p>
</li>
</ol>
<h1>6. 光线跟踪流水线</h1>
<p>最简单的光线跟踪类算法称为<font color=red bold><strong>光线投射recasting</strong></font>，以摄像机为原点，往每个像素发射一根光线，一步一步往前跟踪。光线打到物体表面之后，根据光源和该点的材质计算出一个颜色作为该像素的颜色。这样的结果和光栅化非常相似，只是生成像素的方式有所区别，<strong>它只能得到直接光照，也就是像素颜色来自于光源的直接贡献</strong>。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2025.png" alt="光线投射到物体表面，计算颜色值后填充到像素"></p>
<p>用光栅化渲染的时候，要解答的问题是这个物体占据了哪些像素，而光线投射解答的是沿着这条光线的方向能看到什么物体。这个区别使得两者渲染流程完全不同了。</p>
<p>光栅化是<strong>一个物体</strong>送去渲染一个三角形。光栅化 GPU 并没有场景的概念，拿到什么渲什么。光线投射就不能这样了，因为光线发出的时候并不知道会打到哪里，必须要把<strong>整个场景</strong>全部都提交给 GPU 才能开始跟踪。渲染的单位不再是三角形，而是整个场景。</p>
<p>复杂一点，当光线打到物体表面之后，不是就此停止，而是可以继续折射、反射、散射等产生多条新的光线，继续跟踪，直到达到光源为止。最后从光源反向计算每次达到物体的颜色，得到这个像素的颜色，这就是整体的光线跟踪。</p>
<p>既然场景都有了，不需要额外的新数据就能完成这整个操作，自然达成了实时渲染梦寐以求的<strong>全局光照</strong>， <font color=red bold><strong>GI （Global illumination）</strong></font>不是直接来自于光源，而是来自于其他光路间接贡献的光照，称为<strong>间接光照</strong>。之前为了实时计算间接光照， AO 有 AO 的方法，反射有反射的方法，折射有折射的方法，散射有散射的方法，互相还可能存在冲突，无法一起使用。有了光线跟踪之后，整个 GI  可以用一致的方法统一完成，开发简单了，效果还更好。</p>
<p>回到物体本身，不管是光栅化还是光线跟踪，物体都可以用三角形的几何表示，那么光线跟踪的过程一定会涉及到光线和三角形的求交。理论上我们只需要这个求交判断，就能通过把所有光线和所有三角形都求交一遍来实现光线跟踪，但这样效率实在太低了，计算量大的惊人。所以长期以来研究的重点就是如何尽可能早的把不会相交的情况排除掉，以加速跟踪。常用的是把整个场景放到一个树形的加速结构，如果一根光线和一个子树已经不相交了，那就一定不会和子树里的任何物体相交，也就能排除掉整个子树。光线跟踪领域常用的加速结构叫 <font color=red bold><strong>BVH</strong></font>，这种树的叶子节点是物体本身，物体的包围和之间的关系往上组成为一级的树。用三角形表达物体属于显式表达，给一堆三角形显式的定义出一个几何体。另一种常见的形式是<strong>过程式物体属于隐式表达</strong>，他给的是一个包围盒和一个隐式函数，传入一个 x y z 坐标，这个函数告诉你是不是在他表示的物体上。这两种物体表达都可以用于光线跟踪。</p>
<p>有了这些基础，我们就可以开始来看看 GPU 的光线跟踪是怎么回事。首先我们肯定会需要一个让硬件可以访问的加速结构，而且必须针对实时应用来设计。我们需要对几何体本身建立加速结构，然后摆到场景里，建立场景整体的加速结构，这就有了物体的加速结构和场景的加速结构两层的关系。其次，游戏场景里会有很多动态物体，如果物体移动就得重建整个加速结构，开销太大了。于是这样的加速结构还需要支持<strong>局部更新</strong>。有了加速结构之后，把它提交给GPU，它也是整个渲染流程的核心。</p>
<p>光线跟踪流水线，引入了多个新类型的shader，从<strong>ray generation shader</strong>作为起点发出光线，光线遍历加速结构，找到可能有相交的叶子节点。如果是三角形几何体， GPU 就会把光线和三角形求交。如果是过程式物体，光线只会和物体的包围盒求交。然后调用 <strong>intersection shader</strong> 来确定是否真的和物体相交了，如果达到了就转到 any hit shader 判定是否要继续往前跟踪。</p>
<p>光线打到物体的最近点，会调用一次 <strong>closed hit shader</strong> 来计算颜色，这里可以产生新的光线递归或者颜色。如果什么都没达到，就会用 <strong>miss shader</strong> 算颜色。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2026.png" alt="光线追踪流程图"></p>
<p>前面说过光线跟踪的时候并不知道一根光线发出去能打到什么物体，所以得把整个场景的所有物体的几种 shader 都放在一张表里。 GPU 会根据打到物体的 ID 动态决定调用哪个shader。这和光栅化很不一样，光栅化的时候是开始画一个物体之前就能静态决定用哪一组shader。因此<strong>光线跟踪的 shader 有动态调用的能力</strong>，称为Callable shader。 这些类型的 shader 仍然是在 unified shader 单元里执行的。 <strong>GPU 上的 RT core 做的是求交的加速操作</strong>。其实不管是D3D12 还是Vulkan里的光线跟踪 API 都只是定义了一个接口。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2027.png" alt="场景物体shader表"></p>
<p>Imagination 提出过光线跟踪的 6 个等级，通过这样的定义，我们可以看到现实中的光线跟踪正处于哪个阶段，也能大致了解未来会如何发展。</p>
<p><img src="/images/Graphics%20Pipeline%20eeaa3b4adba74402a6e7fa7cd35a02a9/Untitled%2028.png" alt="光线跟踪的六个等级"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vv-carrot</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"forest","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
